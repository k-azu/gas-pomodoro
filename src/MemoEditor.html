<script>
  var MemoEditor = (function () {
    var RECORD_KEY = "gas_pomodoro_record_desc";
    var INT_KEY = "gas_pomodoro_int_note";
    var memoEditor = null;
    var recordEditor = null;
    var interruptionEditor = null;
    var viewerEditor = null;
    var memoDebounce = null;
    var recordDebounce = null;
    var intDebounce = null;
    var memoScrollCache = {}; // documentId -> scrollTop
    var currentMemoDocId = null;
    var _navigateBack = null;
    var _mentionsConfig = null;

    function ls(key) {
      try { return localStorage.getItem(key) || ""; } catch (e) { return ""; }
    }
    function lsSet(key, val) {
      try { localStorage.setItem(key, val); } catch (e) {}
    }

    // =========================================================
    // Drive image proxy: IndexedDB cache + pre-resolve
    // =========================================================
    // Markdown persists Drive file URLs (https://drive.google.com/file/d/{ID}/view).
    // Display uses blob URLs created from cached / fetched image data.
    var DRIVE_FILE_RE = /drive\.google\.com\/file\/d\/([^/]+)\/view/;
    var DRIVE_URL_GLOBAL_RE = /https:\/\/drive\.google\.com\/file\/d\/([^/\s)"]+)\/view/g;
    var blobToDriveUrl = {}; // blobUrl -> driveFileUrl
    var fileIdToBlobUrl = {}; // fileId -> blobUrl

    function driveFileUrl(fileId) {
      return "https://drive.google.com/file/d/" + fileId + "/view";
    }

    // Replace blob URLs with Drive URLs in markdown for persistence
    function blobUrlsToDrive(md) {
      for (var blobUrl in blobToDriveUrl) {
        md = md.split(blobUrl).join(blobToDriveUrl[blobUrl]);
      }
      return md;
    }

    // --- IndexedDB cache ---
    var DB_NAME = "gas_pomodoro_images";
    var DB_VERSION = 1;
    var STORE_NAME = "images";
    var _dbInstance = null;

    function openImageDB() {
      if (_dbInstance) return Promise.resolve(_dbInstance);
      return new Promise(function (resolve, reject) {
        var req = indexedDB.open(DB_NAME, DB_VERSION);
        req.onupgradeneeded = function () {
          req.result.createObjectStore(STORE_NAME);
        };
        req.onsuccess = function () { _dbInstance = req.result; resolve(_dbInstance); };
        req.onerror = function () { reject(req.error); };
      });
    }

    function getCachedImage(fileId) {
      return openImageDB().then(function (db) {
        return new Promise(function (resolve, reject) {
          var tx = db.transaction(STORE_NAME, "readonly");
          var req = tx.objectStore(STORE_NAME).get(fileId);
          req.onsuccess = function () { resolve(req.result || null); };
          req.onerror = function () { reject(req.error); };
        });
      });
    }

    function setCachedImage(fileId, blob) {
      return openImageDB().then(function (db) {
        return new Promise(function (resolve, reject) {
          var tx = db.transaction(STORE_NAME, "readwrite");
          tx.objectStore(STORE_NAME).put(blob, fileId);
          tx.oncomplete = function () { resolve(); };
          tx.onerror = function () { reject(tx.error); };
        });
      });
    }

    // --- Resolve helpers ---
    function base64ToBlob(base64, mimeType) {
      var byteChars = atob(base64);
      var bytes = new Uint8Array(byteChars.length);
      for (var i = 0; i < byteChars.length; i++) bytes[i] = byteChars.charCodeAt(i);
      return new Blob([bytes], { type: mimeType });
    }

    function registerBlobUrl(fileId, blobUrl) {
      fileIdToBlobUrl[fileId] = blobUrl;
      blobToDriveUrl[blobUrl] = driveFileUrl(fileId);
      return blobUrl;
    }

    function resolveFileId(fileId) {
      if (fileIdToBlobUrl[fileId]) return Promise.resolve(fileIdToBlobUrl[fileId]);
      return getCachedImage(fileId).then(function (cached) {
        if (cached) {
          return registerBlobUrl(fileId, URL.createObjectURL(cached));
        }
        return serverCall("getImageBase64", fileId).then(function (result) {
          var blob = base64ToBlob(result.base64, result.mimeType);
          setCachedImage(fileId, blob);
          return registerBlobUrl(fileId, URL.createObjectURL(blob));
        });
      }).catch(function (err) {
        console.error("画像の解決に失敗:", fileId, err);
        return driveFileUrl(fileId);
      });
    }

    // Replace all Drive thumbnail URLs in markdown with blob URLs
    function resolveDriveUrls(md) {
      if (!md) return Promise.resolve(md);
      var ids = {};
      var match;
      DRIVE_URL_GLOBAL_RE.lastIndex = 0;
      while ((match = DRIVE_URL_GLOBAL_RE.exec(md)) !== null) {
        ids[match[1]] = match[0];
      }
      var keys = Object.keys(ids);
      if (keys.length === 0) return Promise.resolve(md);
      return Promise.all(keys.map(function (fileId) {
        return resolveFileId(fileId).then(function (blobUrl) {
          return { driveUrl: ids[fileId], blobUrl: blobUrl };
        });
      })).then(function (results) {
        results.forEach(function (r) {
          md = md.split(r.driveUrl).join(r.blobUrl);
        });
        return md;
      });
    }

    // =========================================================
    // Image upload
    // =========================================================
    var MAX_CLIENT_BYTES = 10 * 1024 * 1024; // 10 MB (same as server limit)

    function handleImageUpload(file) {
      if (file.size > MAX_CLIENT_BYTES) {
        var sizeMB = (file.size / 1024 / 1024).toFixed(1);
        return Promise.reject(new Error("画像サイズが上限(10MB)を超えています: " + sizeMB + "MB"));
      }
      var mimeType = file.type || "image/jpeg";
      var ext = {"image/jpeg":"jpg","image/png":"png","image/gif":"gif","image/webp":"webp"}[mimeType] || "jpg";
      var now = new Date();
      var ts = now.getFullYear()
        + ("0"+(now.getMonth()+1)).slice(-2)
        + ("0"+now.getDate()).slice(-2)
        + "_"
        + ("0"+now.getHours()).slice(-2)
        + ("0"+now.getMinutes()).slice(-2)
        + ("0"+now.getSeconds()).slice(-2);
      var uploadName = "pomodoro_" + ts + "." + ext;

      return new Promise(function (resolve, reject) {
        var reader = new FileReader();
        reader.onload = function () {
          var base64 = reader.result.split(",")[1];
          serverCall("uploadImage", base64, uploadName, mimeType)
            .then(function (result) {
              var blob = new Blob([file], { type: mimeType });
              var blobUrl = URL.createObjectURL(blob);
              registerBlobUrl(result.fileId, blobUrl);
              setCachedImage(result.fileId, blob);
              resolve(blobUrl);
            })
            .catch(reject);
        };
        reader.onerror = function () {
          reject(new Error("ファイルの読み込みに失敗しました"));
        };
        reader.readAsDataURL(file);
      });
    }

    // =========================================================
    // Init: pre-resolve Drive URLs, then mount editors
    // =========================================================
    function init(memoContent) {
      if (typeof window.mountMemoEditor !== "function") {
        console.warn("MemoEditor: mountMemoEditor not available");
        return Promise.resolve();
      }

      return Promise.all([
        resolveDriveUrls(memoContent || ""),
        resolveDriveUrls(ls(RECORD_KEY)),
        resolveDriveUrls(ls(INT_KEY)),
      ]).then(function (resolved) {
        mountEditors(resolved[0], resolved[1], resolved[2]);
      });
    }

    function mountEditors(memoMd, recordMd, intMd) {
      // --- Mention navigation ---
      var navStack = []; // [{ tab, memoId }]

      function mentionItems(query) {
        if (typeof MemoSidebar === "undefined") return [];
        var allMemos = MemoSidebar.getAllMemos();
        var q = query.toLowerCase();
        return allMemos
          .filter(function (m) { return m.name.toLowerCase().indexOf(q) !== -1; })
          .slice(0, 8)
          .map(function (m) { return { id: m.id, label: m.name }; });
      }

      function mentionClick(id) {
        if (typeof MemoSidebar === "undefined") return;
        var currentTab = TabPanel.getActiveTab();
        var currentMemoId = MemoSidebar.getActiveId();

        navStack.push({ tab: currentTab, memoId: currentMemoId });
        history.pushState({ mentionNav: true }, "");

        TabPanel.switchTab("memo");
        MemoSidebar.selectMemo(id);
        updateBackButton();
      }

      _navigateBack = function () {
        if (navStack.length === 0) return;
        var prev = navStack.pop();
        TabPanel.switchTab(prev.tab);
        if (prev.memoId && prev.tab === "memo") {
          MemoSidebar.selectMemo(prev.memoId);
        }
        if (prev.taskNode && prev.tab === "task" && typeof TaskPanel !== "undefined") {
          TaskPanel.selectNode(prev.taskNode.type, prev.taskNode.id);
        }
        updateBackButton();
      };

      function updateBackButton() {
        var btn = document.getElementById("memo-back-btn");
        if (btn) btn.style.display = navStack.length > 0 ? "" : "none";
      }

      window.addEventListener("popstate", function (e) {
        if (navStack.length > 0) {
          _navigateBack();
        }
      });

      // --- Task mention navigation ---
      function taskMentionItems(query) {
        if (typeof TaskStore === "undefined") return [];
        var q = query.toLowerCase();
        // Synchronous cache fallback: we need items right away
        // TaskStore returns promises; we pre-cache data for mentions
        var items = _taskMentionCache || [];
        return items
          .filter(function (m) { return m.label.toLowerCase().indexOf(q) !== -1; })
          .slice(0, 8);
      }

      function taskMentionClick(id) {
        if (typeof TaskPanel === "undefined") return;
        var currentTab = TabPanel.getActiveTab();
        var currentMemoId = typeof MemoSidebar !== "undefined" ? MemoSidebar.getActiveId() : null;
        var taskNode = typeof TaskPanel !== "undefined" ? TaskPanel.getSelectedNode() : null;

        navStack.push({ tab: currentTab, memoId: currentMemoId, taskNode: taskNode });
        history.pushState({ mentionNav: true }, "");

        TabPanel.switchTab("task");
        TaskPanel.selectNode("task", id);
        updateBackButton();
      }

      function entityMentionItems(query) {
        if (typeof TaskStore === "undefined") return [];
        var q = query.toLowerCase();
        var items = _entityMentionCache || [];
        return items
          .filter(function (m) { return m.label.toLowerCase().indexOf(q) !== -1; })
          .slice(0, 8);
      }

      function entityMentionClick(id) {
        if (typeof TaskPanel === "undefined") return;
        var currentTab = TabPanel.getActiveTab();
        var currentMemoId = typeof MemoSidebar !== "undefined" ? MemoSidebar.getActiveId() : null;
        var taskNode = typeof TaskPanel !== "undefined" ? TaskPanel.getSelectedNode() : null;

        navStack.push({ tab: currentTab, memoId: currentMemoId, taskNode: taskNode });
        history.pushState({ mentionNav: true }, "");

        // Parse type from id: "project:uuid" or "case:uuid"
        var parts = id.split(":");
        var type = parts[0];
        var entityId = parts.slice(1).join(":");

        TabPanel.switchTab("task");
        TaskPanel.selectNode(type, entityId);
        updateBackButton();
      }

      // Pre-cache mention data (refreshed periodically)
      var _taskMentionCache = [];
      var _entityMentionCache = [];

      function refreshMentionCaches() {
        if (typeof TaskStore === "undefined") return;
        Promise.all([
          TaskStore.getAllTasks(),
          TaskStore.getAllProjects(),
          TaskStore.getAllCases(),
        ]).then(function (results) {
          var tasks = results[0];
          var projects = results[1];
          var cases = results[2];

          // Build project name map
          var projMap = {};
          projects.forEach(function (p) { projMap[p.id] = p.name; });
          var caseMap = {};
          cases.forEach(function (c) { caseMap[c.id] = c; });

          // Task mention cache
          _taskMentionCache = tasks.map(function (t) {
            var path = projMap[t.projectId] || "";
            if (t.caseId && caseMap[t.caseId]) {
              path += " > " + caseMap[t.caseId].name;
            }
            return {
              id: t.id,
              label: t.name + (path ? " (" + path + ")" : ""),
            };
          });

          // Entity mention cache (projects + cases)
          _entityMentionCache = [];
          projects.forEach(function (p) {
            _entityMentionCache.push({
              id: "project:" + p.id,
              label: p.name,
            });
          });
          cases.forEach(function (c) {
            var projName = projMap[c.projectId] || "";
            _entityMentionCache.push({
              id: "case:" + c.id,
              label: projName ? projName + "::" + c.name : c.name,
            });
          });
        }).catch(function () {});
      }

      // Refresh caches on init and on TaskStore changes
      setTimeout(refreshMentionCaches, 500);
      if (typeof TaskStore !== "undefined") {
        TaskStore.on("dataChanged", function () {
          refreshMentionCaches();
        });
      }

      var mentionsConfig = [
        {
          char: "@",
          scheme: "mention",
          prefix: "@",
          items: mentionItems,
          onClick: mentionClick,
        },
        {
          char: "#",
          scheme: "task",
          prefix: "#",
          items: taskMentionItems,
          onClick: taskMentionClick,
        },
        {
          char: "!",
          scheme: "entity",
          prefix: "!",
          items: entityMentionItems,
          onClick: entityMentionClick,
        },
      ];
      _mentionsConfig = mentionsConfig;

      // 1. Memo editor
      var memoContainer = document.getElementById("memo-editor-container");
      if (memoContainer) {
        memoEditor = window.mountMemoEditor(memoContainer, {
          initialValue: memoMd,
          onChange: function (md) {
            if (memoDebounce) clearTimeout(memoDebounce);
            memoDebounce = setTimeout(function () {
              if (typeof MemoSidebar !== "undefined") MemoSidebar.saveCurrent();
            }, 500);
          },
          onImageUpload: handleImageUpload,
          mentions: mentionsConfig,
          placeholder: "メモを入力...",
          defaultMode: "wysiwyg",
          style: { height: "100%" },
        });
      }

      // 2. Record description editor
      var recordContainer = document.getElementById("record-editor-container");
      if (recordContainer) {
        recordEditor = window.mountMemoEditor(recordContainer, {
          initialValue: recordMd,
          onChange: function (md) {
            if (recordDebounce) clearTimeout(recordDebounce);
            recordDebounce = setTimeout(function () { lsSet(RECORD_KEY, blobUrlsToDrive(md)); }, 500);
          },
          onImageUpload: handleImageUpload,
          mentions: mentionsConfig,
          placeholder: "何に取り組みましたか？",
          defaultMode: "wysiwyg",
          style: { height: "100%" },
        });
      }

      // 3. Interruption note editor
      var intContainer = document.getElementById("int-note-editor-container");
      if (intContainer) {
        interruptionEditor = window.mountMemoEditor(intContainer, {
          initialValue: intMd,
          onChange: function (md) {
            if (intDebounce) clearTimeout(intDebounce);
            intDebounce = setTimeout(function () { lsSet(INT_KEY, blobUrlsToDrive(md)); }, 500);
          },
          onImageUpload: handleImageUpload,
          mentions: mentionsConfig,
          placeholder: "中断メモ...",
          defaultMode: "wysiwyg",
          style: { height: "100%" },
        });
      }

      // 4. Viewer editor
      var viewerContainer = document.getElementById("viewer-editor-container");
      if (viewerContainer) {
        viewerEditor = window.mountMemoEditor(viewerContainer, {
          initialValue: "",
          onImageUpload: handleImageUpload,
          mentions: mentionsConfig,
          placeholder: "",
          defaultMode: "wysiwyg",
          style: { height: "100%" },
        });
      }

      // Open original Drive image on double-click
      document.addEventListener("dblclick", function (e) {
        var img = e.target;
        if (img.tagName !== "IMG") return;
        var dUrl = blobToDriveUrl[img.src];
        if (dUrl) window.open(dUrl, "_blank");
      });
    }

    // =========================================================
    // Public API
    // =========================================================
    function normalizeEmpty(val) {
      if (!val) return "";
      if (!val.replace(/&nbsp;/g, "").replace(/[\s\u00a0]/g, "")) return "";
      return val;
    }

    // --- Memo ---
    function getValue() {
      if (memoEditor) return blobUrlsToDrive(normalizeEmpty(memoEditor.getValue()));
      return "";
    }

    function setValue(markdown) {
      if (!memoEditor) return Promise.resolve();
      return resolveDriveUrls(markdown).then(function (resolved) {
        if (memoEditor.getValue() === resolved) return;
        memoEditor.setValue(resolved);
        restoreMemoScroll(currentMemoDocId);
      });
    }

    function setEditable(editable) {
      if (memoEditor && memoEditor.setEditable) memoEditor.setEditable(editable);
    }

    function getMemoScrollEl() {
      var container = document.getElementById("memo-editor-container");
      if (!container) return null;
      return container.querySelector(".mdg-editor-content") || null;
    }

    function saveMemoScroll() {
      if (!currentMemoDocId) return;
      var el = getMemoScrollEl();
      if (el) memoScrollCache[currentMemoDocId] = el.scrollTop;
    }

    function restoreMemoScroll(docId) {
      var pos = memoScrollCache[docId];
      if (pos == null) return;
      setTimeout(function () {
        var el = getMemoScrollEl();
        if (el) el.scrollTop = pos;
      }, 0);
    }

    function switchDocument(id, markdown) {
      if (!memoEditor || !memoEditor.switchDocument) return Promise.resolve();
      saveMemoScroll();
      currentMemoDocId = id;
      return resolveDriveUrls(markdown).then(function (resolved) {
        memoEditor.switchDocument(id, resolved);
        restoreMemoScroll(id);
      });
    }

    function clear() {
      if (memoEditor) memoEditor.setValue("");
    }

    // --- Record description ---
    function getRecordValue() {
      if (recordEditor) return blobUrlsToDrive(normalizeEmpty(recordEditor.getValue()));
      return ls(RECORD_KEY);
    }

    function setRecordValue(markdown) {
      if (!recordEditor) { lsSet(RECORD_KEY, markdown); return; }
      resolveDriveUrls(markdown).then(function (resolved) {
        recordEditor.setValue(resolved);
        lsSet(RECORD_KEY, markdown);
      });
    }

    function clearRecord() {
      if (recordEditor) recordEditor.setValue("");
      lsSet(RECORD_KEY, "");
    }

    // --- Interruption note ---
    function getInterruptionValue() {
      if (interruptionEditor) return blobUrlsToDrive(normalizeEmpty(interruptionEditor.getValue()));
      return ls(INT_KEY);
    }

    function setInterruptionValue(markdown) {
      if (!interruptionEditor) { lsSet(INT_KEY, markdown); return; }
      resolveDriveUrls(markdown).then(function (resolved) {
        interruptionEditor.setValue(resolved);
        lsSet(INT_KEY, markdown);
      });
    }

    function clearInterruption() {
      if (interruptionEditor) interruptionEditor.setValue("");
      lsSet(INT_KEY, "");
    }

    // --- Viewer ---
    function getViewerValue() {
      if (viewerEditor) return blobUrlsToDrive(normalizeEmpty(viewerEditor.getValue()));
      return "";
    }

    function setViewerValue(markdown) {
      if (!viewerEditor) return;
      resolveDriveUrls(markdown).then(function (resolved) {
        viewerEditor.setValue(resolved);
      });
    }

    function clearViewer() {
      if (viewerEditor) viewerEditor.setValue("");
    }

    return {
      init: init,
      getValue: getValue,
      setValue: setValue,
      setEditable: setEditable,
      switchDocument: switchDocument,
      clear: clear,
      getRecordValue: getRecordValue,
      setRecordValue: setRecordValue,
      clearRecord: clearRecord,
      getInterruptionValue: getInterruptionValue,
      setInterruptionValue: setInterruptionValue,
      clearInterruption: clearInterruption,
      getViewerValue: getViewerValue,
      setViewerValue: setViewerValue,
      clearViewer: clearViewer,
      navigateBack: function () { if (_navigateBack) _navigateBack(); },
      getMentionsConfig: function () { return _mentionsConfig; },
    };
  })();
</script>
