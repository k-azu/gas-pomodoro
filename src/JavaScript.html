<script>
  // --- Utility: Promise wrapper for google.script.run ---
  function serverCall(functionName) {
    var args = Array.prototype.slice.call(arguments, 1);
    return new Promise(function (resolve, reject) {
      var runner = google.script.run
        .withSuccessHandler(resolve)
        .withFailureHandler(reject);
      runner[functionName].apply(runner, args);
    });
  }

  function showLoading(show) {
    var el = document.getElementById("loading-overlay");
    if (show) el.classList.add("visible");
    else el.classList.remove("visible");
  }

  // --- App State & Timer Engine ---
  var App = (function () {
    var STORAGE_KEY = "gas_pomodoro_state";

    // Default state
    var state = {
      phase: "idle", // idle | work | interrupted | shortBreak | longBreak | breakDone
      breakType: null, // 'shortBreak' | 'longBreak' — remembers which break just ended
      elapsedSeconds: 0,
      targetReached: false, // whether target time notification has fired
      startTimestamp: null, // wall-clock start time (ms)
      totalSeconds: 0, // total duration for current timer
      pomodoroSetIndex: 1, // 1-4
      interruptions: [], // array of { id, type, startTime, endTime, durationSeconds, category, note }
      currentInterruption: null, // { id, type, startTimestamp } while interrupted
      interruptionElapsed: 0, // total ms spent in interruptions (for timer calc)
      config: {
        patternName: "Standard",
        workMinutes: 25,
        shortBreakMinutes: 5,
        longBreakMinutes: 15,
        pomodorosBeforeLongBreak: 4,
      },
      configPatterns: [],
      categories: [],
      interruptionCategories: [],
    };

    var timerInterval = null;

    // --- DOM Cache ---
    var dom = {};

    function cacheDom() {
      dom.timerDisplay = document.getElementById("timer-display");
      dom.phaseLabel = document.getElementById("phase-label");
      dom.timerCard = document.getElementById("timer-card");
      dom.pomodoroDots = document.getElementById("pomodoro-dots");
      dom.interruptionBadge = document.getElementById("interruption-badge");
      dom.btnStart = document.getElementById("btn-start");
      dom.workControls = document.getElementById("work-controls");
      dom.breakControls = document.getElementById("break-controls");
      dom.breakDonePanel = document.getElementById("break-done-panel");
      dom.recordActions = document.getElementById("record-form-actions");
      dom.workProgress = document.getElementById("work-progress");
      dom.patternSelector = document.getElementById("pattern-selector");
      dom.patternSelect = document.getElementById("pattern-select");
      dom.statsPomodoros = document.getElementById("stats-pomodoros");
      dom.statsAbandoned = document.getElementById("stats-abandoned");
      dom.statsWorkTime = document.getElementById("stats-work-time");
      dom.statsBreakTime = document.getElementById("stats-break-time");
      dom.statsWorkIntTime = document.getElementById("stats-work-int-time");
      dom.statsNonworkIntTime = document.getElementById("stats-nonwork-int-time");
      dom.historyList = document.getElementById("history-list");
    }

    // --- localStorage persistence ---
    var saveStateTimer = null;

    function saveState() {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      } catch (e) {}
    }

    function saveStateDebounced() {
      if (saveStateTimer) return;
      saveStateTimer = setTimeout(function () {
        saveStateTimer = null;
        saveState();
      }, 5000);
    }

    function flushSaveState() {
      if (saveStateTimer) {
        clearTimeout(saveStateTimer);
        saveStateTimer = null;
        saveState();
      }
    }

    function loadState() {
      try {
        var saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
          var parsed = JSON.parse(saved);
          Object.keys(parsed).forEach(function (k) {
            if (k === "config") {
              Object.assign(state.config, parsed.config);
            } else {
              state[k] = parsed[k];
            }
          });
        }
      } catch (e) {}
    }

    function clearState() {
      state.phase = "idle";
      state.breakType = null;
      state.elapsedSeconds = 0;
      state.targetReached = false;
      state.startTimestamp = null;
      state.totalSeconds = 0;
      state.pomodoroSetIndex = 1;

      state.interruptions = [];
      state.currentInterruption = null;
      state.interruptionElapsed = 0;
      saveState();
    }

    // --- Timer Core ---
    function tick() {
      var now = Date.now();

      if (state.phase === "interrupted") {
        // Show interruption elapsed time in main timer (count up)
        var intStart = state.currentInterruption.startTimestamp;
        var intElapsed = Math.floor((now - intStart) / 1000);
        var intHours = Math.floor(intElapsed / 3600);
        var intMins = Math.floor((intElapsed % 3600) / 60);
        var intSecs = intElapsed % 60;
        if (intHours > 0) {
          dom.timerDisplay.textContent =
            intHours + ":" + String(intMins).padStart(2, "0") + ":" + String(intSecs).padStart(2, "0");
        } else {
          dom.timerDisplay.textContent =
            String(intMins).padStart(2, "0") + ":" + String(intSecs).padStart(2, "0");
        }
        return;
      }

      // Wall-clock count-up calculation (excluding interruption time)
      var elapsed = now - state.startTimestamp - state.interruptionElapsed;
      state.elapsedSeconds = Math.max(0, Math.floor(elapsed / 1000));

      updateDisplay();
      saveStateDebounced();

      // Target time reached check (notify once)
      if (!state.targetReached && state.elapsedSeconds >= state.totalSeconds) {
        state.targetReached = true;
        onTargetReached();
      }
    }

    function startTimer(phase, durationMinutes) {
      state.phase = phase;
      state.totalSeconds = durationMinutes * 60;
      state.elapsedSeconds = 0;
      state.targetReached = false;
      state.startTimestamp = Date.now();
      state.interruptionElapsed = 0;

      if (phase === "work") {
        state.interruptions = [];
        state.currentInterruption = null;
        // Clear form for new pomodoro
        RecordForm.clearForm();
      }

      saveState();
      updateDisplay();
      updateControls();
      startInterval();
    }

    function startInterval() {
      stopInterval();
      timerInterval = setInterval(tick, 1000);
    }

    function stopInterval() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
    }

    // --- Interruption: start/end ---
    function startInterruption() {
      if (state.phase !== "work") return;

      var id = RecordForm.generateUUID();
      state.currentInterruption = {
        id: id,
        startTimestamp: Date.now(),
      };
      state.phase = "interrupted";

      // Reset form fields
      var typeCheckbox = document.getElementById("int-type-work");
      if (typeCheckbox) typeCheckbox.checked = true;
      MemoEditor.clearInterruption();
      populateInterruptionCategorySelect();

      saveState();
      updateDisplay();
      updateControls();
    }

    var intCombo = null;

    function initIntCombo() {
      if (intCombo) return;
      intCombo = CategoryCombo.create({
        inputId: "int-category",
        categories: state.interruptionCategories || [],
        sheetType: "InterruptionCategories",
        onSelect: function () {},
      });
    }

    function populateInterruptionCategorySelect() {
      initIntCombo();
      intCombo.setCategories(state.interruptionCategories);
      intCombo.setValue("");
    }

    function ensureInterruptionCategory(category) {
      if (!category) return Promise.resolve();
      var exists = state.interruptionCategories.some(function (c) {
        return c.name === category;
      });
      if (exists) return Promise.resolve();
      var color = intCombo ? intCombo.getColor() : "#757575";
      return serverCall("addInterruptionCategory", category, color).then(function (result) {
        if (result.success) {
          return serverCall("getInterruptionCategories").then(function (cats) {
            if (cats) {
              state.interruptionCategories = cats;
              if (intCombo) intCombo.setCategories(cats);
            }
          });
        }
      });
    }

    function endInterruption() {
      if (state.phase !== "interrupted" || !state.currentInterruption) return;

      var now = Date.now();
      var durationMs = now - state.currentInterruption.startTimestamp;
      var durationSeconds = Math.round(durationMs / 1000);

      // Read form values
      var typeCheckbox = document.getElementById("int-type-work");
      var type = typeCheckbox && typeCheckbox.checked ? "work" : "nonWork";
      var category = intCombo ? intCombo.getValue() : document.getElementById("int-category").value.trim();
      var note = (MemoEditor.getInterruptionValue() || "").trim();

      state.interruptions.push({
        id: state.currentInterruption.id,
        type: type,
        startTime: new Date(
          state.currentInterruption.startTimestamp,
        ).toISOString(),
        endTime: new Date(now).toISOString(),
        durationSeconds: durationSeconds,
        category: category,
        note: note,
      });

      state.interruptionElapsed += durationMs;
      state.currentInterruption = null;
      state.phase = "work";
      saveState();
      updateDisplay();
      updateControls();

      // Auto-create interruption category if new
      ensureInterruptionCategory(category);
    }

    function discardInterruption() {
      if (state.phase !== "interrupted" || !state.currentInterruption) return;
      // Discard: no record, no interruptionElapsed adjustment
      // The interruption period counts as work time (as if it didn't happen)
      state.currentInterruption = null;
      state.phase = "work";
      saveState();
      updateDisplay();
      updateControls();
    }

    function completeBreak() {
      if (state.phase !== "shortBreak" && state.phase !== "longBreak") return;
      // Timer keeps running — actual duration is captured when user picks next action
      state.breakType = state.phase;
      state.phase = "breakDone";
      saveState();
      updateDisplay();
      updateControls();
    }

    function onTargetReached() {
      if (state.phase === "work") {
        NotificationManager.notify("作業時間到達", "設定時間に達しました。");
      } else if (state.phase === "shortBreak" || state.phase === "longBreak") {
        NotificationManager.notify("休憩時間到達", "設定時間に達しました。");
      }
      saveState();
      updateDisplay();
    }

    function saveBreakRecord() {
      var now = new Date();
      var startTime = new Date(state.startTimestamp);
      var durationSeconds =
        (state.breakType === "shortBreak"
          ? state.config.shortBreakMinutes
          : state.config.longBreakMinutes) * 60;
      var record = {
        id: RecordForm.generateUUID(),
        date: RecordForm.formatDate(now),
        startTime: startTime.toISOString(),
        endTime: now.toISOString(),
        durationSeconds: durationSeconds,
        actualDurationSeconds: Math.round(
          (now.getTime() - startTime.getTime()) / 1000,
        ),
        type: state.breakType,
        description: "",
        category: "",
        workInterruptions: 0,
        nonWorkInterruptions: 0,
        workInterruptionSeconds: 0,
        nonWorkInterruptionSeconds: 0,
        completionStatus: "completed",
        pomodoroSetIndex: state.pomodoroSetIndex,
      };
      return serverCall("saveRecord", record);
    }

    function continueWork() {
      if (state.phase !== "breakDone") return;
      saveBreakRecord().then(function () {
        refreshAll();
        startTimer("work", state.config.workMinutes);
      });
    }

    function endSession() {
      if (state.phase !== "breakDone") return;
      saveBreakRecord().then(function () {
        stopInterval();
        clearState();
        updateDisplay();
        updateControls();
        refreshAll();
      });
    }

    // Called after record form submission — go to break
    function onRecordSaved() {
      var limit = state.config.pomodorosBeforeLongBreak;
      var isLongBreak = state.pomodoroSetIndex >= limit;

      if (isLongBreak) {
        state.pomodoroSetIndex = 1;
        startTimer("longBreak", state.config.longBreakMinutes);
      } else {
        state.pomodoroSetIndex++;
        startTimer("shortBreak", state.config.shortBreakMinutes);
      }
    }

    // Called after record form submission — skip break, next work
    function startNextWork() {
      var limit = state.config.pomodorosBeforeLongBreak;
      if (state.pomodoroSetIndex >= limit) {
        state.pomodoroSetIndex = 1;
      } else {
        state.pomodoroSetIndex++;
      }
      startTimer("work", state.config.workMinutes);
    }

    // Called after record form submission — end session
    function endWorkSession() {
      stopInterval();
      clearState();
      updateDisplay();
      updateControls();
    }

    function startWork() {
      startTimer("work", state.config.workMinutes);
    }

    function onPatternChange(patternName) {
      var pattern = state.configPatterns.find(function (p) {
        return p.patternName === patternName;
      });
      if (!pattern) return;
      state.config = pattern;
      saveState();
      updateDisplay();
      updateDots();
    }

    // --- UI Update ---
    var lastDotsKey = null;
    var lastBadgeCount = -1;

    function updateDisplay() {
      var total;
      if (state.phase === "interrupted" && state.currentInterruption) {
        total = Math.max(0, Math.floor((Date.now() - state.currentInterruption.startTimestamp) / 1000));
      } else {
        total = state.elapsedSeconds || 0;
      }
      var hours = Math.floor(total / 3600);
      var mins = Math.floor((total % 3600) / 60);
      var secs = total % 60;

      if (hours > 0) {
        dom.timerDisplay.textContent =
          hours + ":" + String(mins).padStart(2, "0") + ":" + String(secs).padStart(2, "0");
      } else {
        dom.timerDisplay.textContent =
          String(mins).padStart(2, "0") + ":" + String(secs).padStart(2, "0");
      }

      // Overtime detection
      var isOvertime = state.elapsedSeconds >= state.totalSeconds &&
        ["work", "shortBreak", "longBreak", "breakDone"].indexOf(state.phase) !== -1;

      // Phase label with target time
      var labels = {
        idle: "準備完了",
        work: isOvertime ? "延長中" : "作業中",
        interrupted: "中断中",
        shortBreak: isOvertime ? "延長中" : "短い休憩",
        longBreak: isOvertime ? "延長中" : "長い休憩",
        breakDone: "休憩終了",
      };
      var label = labels[state.phase] || "";
      // Append static target time for active timer phases
      if (["work", "shortBreak", "longBreak", "breakDone"].indexOf(state.phase) !== -1 && state.totalSeconds > 0) {
        var targetMins = Math.floor(state.totalSeconds / 60);
        var targetSecs = state.totalSeconds % 60;
        var targetStr = targetSecs > 0
          ? targetMins + ":" + String(targetSecs).padStart(2, "0")
          : targetMins + ":00";
        label += " (" + targetStr + ")";
      }
      dom.phaseLabel.textContent = label;

      // Work progress sub-label during interruption
      if (state.phase === "interrupted" && state.totalSeconds > 0) {
        var workElapsed = state.elapsedSeconds || 0;
        var wMins = Math.floor(workElapsed / 60);
        var wSecs = workElapsed % 60;
        var tMins = Math.floor(state.totalSeconds / 60);
        var tSecs = state.totalSeconds % 60;
        dom.workProgress.textContent = "作業 " +
          String(wMins).padStart(2, "0") + ":" + String(wSecs).padStart(2, "0") +
          " / " +
          String(tMins).padStart(2, "0") + ":" + String(tSecs).padStart(2, "0");
        dom.workProgress.style.display = "";
      } else {
        dom.workProgress.style.display = "none";
      }

      // Timer card data attribute for styling
      var dataPhase = state.phase;
      if (dataPhase === "breakDone")
        dataPhase = state.breakType || "shortBreak";
      dom.timerCard.setAttribute("data-phase", dataPhase);

      // Overtime class for visual styling
      if (isOvertime) {
        dom.timerCard.classList.add("overtime");
      } else {
        dom.timerCard.classList.remove("overtime");
      }

      updateDots();
      updateInterruptionBadge();
    }

    function updateDots() {
      var limit = state.config.pomodorosBeforeLongBreak;
      var key = limit + ":" + state.pomodoroSetIndex + ":" + state.phase;
      if (key === lastDotsKey) return;
      lastDotsKey = key;

      var container = dom.pomodoroDots;
      container.innerHTML = "";
      for (var i = 1; i <= limit; i++) {
        var dot = document.createElement("div");
        dot.className = "pomodoro-dot";
        if (i < state.pomodoroSetIndex) {
          dot.classList.add("completed");
        } else if (
          i === state.pomodoroSetIndex &&
          (state.phase === "work" || state.phase === "interrupted")
        ) {
          dot.classList.add("current");
        }
        container.appendChild(dot);
      }
    }

    function updateControls() {
      var isIdle = state.phase === "idle";
      var isWork = state.phase === "work";
      var isInterrupted = state.phase === "interrupted";
      var isBreakDone = state.phase === "breakDone";
      var isBreak = state.phase === "shortBreak" || state.phase === "longBreak";

      // Timer card buttons
      dom.btnStart.style.display = isIdle ? "" : "none";
      dom.workControls.style.display = isWork ? "" : "none";
      dom.breakControls.style.display = isBreak ? "" : "none";
      dom.breakDonePanel.style.display = isBreakDone ? "" : "none";

      // Record form actions (always visible during work)
      dom.recordActions.style.display = isWork ? "" : "none";

      if (isWork || isInterrupted) {
        RecordForm.renderInterruptionList();
      }

      // Update tab panel
      TabPanel.update(state.phase);

      updatePatternInfo();
    }

    function updateInterruptionBadge() {
      var count = state.interruptions.length;
      if (count === lastBadgeCount) return;
      lastBadgeCount = count;

      if (count > 0) {
        dom.interruptionBadge.textContent = count + "件の中断";
        dom.interruptionBadge.style.display = "";
      } else {
        dom.interruptionBadge.style.display = "none";
      }
    }

    var patternSelectPopulated = false;

    function populatePatternSelect() {
      patternSelectPopulated = false;
      doPopulatePatternSelect();
    }

    function doPopulatePatternSelect() {
      if (patternSelectPopulated) return;
      patternSelectPopulated = true;

      var select = dom.patternSelect;
      select.innerHTML = "";
      state.configPatterns.forEach(function (p) {
        var opt = document.createElement("option");
        opt.value = p.patternName;
        opt.textContent =
          p.patternName +
          "  (" +
          p.workMinutes +
          "/" +
          p.shortBreakMinutes +
          "/" +
          p.longBreakMinutes +
          ")";
        if (p.patternName === state.config.patternName) opt.selected = true;
        select.appendChild(opt);
      });
    }

    function updatePatternInfo() {
      if (!dom.patternSelector) return;

      // Show when idle and multiple patterns exist
      var visible = state.phase === "idle" && state.configPatterns.length > 1;
      dom.patternSelector.style.display = visible ? "" : "none";

      dom.patternSelect.disabled = state.phase !== "idle";
      dom.patternSelect.value = state.config.patternName;
    }

    function getState() {
      return state;
    }

    function getInterruptionCategories() {
      return state.interruptionCategories;
    }

    // --- Restore from localStorage on page load ---
    function restoreTimer() {
      if (
        state.phase === "idle" ||
        state.phase === "breakDone"
      )
        return;

      if (state.phase === "interrupted") {
        // Restore interrupted state — unchanged
        populateInterruptionCategorySelect();
        updateDisplay();
        updateControls();
        startInterval();
        return;
      }

      // Wall-clock count-up recovery
      var now = Date.now();
      var elapsed = now - state.startTimestamp - state.interruptionElapsed;
      state.elapsedSeconds = Math.max(0, Math.floor(elapsed / 1000));

      // Check if target was reached while tab was away
      if (!state.targetReached && state.elapsedSeconds >= state.totalSeconds) {
        state.targetReached = true;
        onTargetReached();
      }

      updateDisplay();
      updateControls();
      startInterval();
    }

    // --- Init ---
    function init() {
      loadState();
      cacheDom();
      showLoading(true);

      // Flush debounced saveState on tab close
      window.addEventListener("beforeunload", flushSaveState);

      serverCall("getAllInitData")
        .then(function (data) {
          state.configPatterns = data.timerConfigs;
          // Use saved pattern name from localStorage, or fall back to first pattern
          var savedName = state.config.patternName;
          var match = state.configPatterns.find(function (p) {
            return p.patternName === savedName;
          });
          if (match) {
            state.config = match;
          } else {
            state.config = state.configPatterns[0];
          }
          state.categories = data.categories;
          state.interruptionCategories = data.interruptionCategories;
          populatePatternSelect();
          RecordForm.populateCategories(data.categories);
          displayStats(data.todayStats);
          displayHistory(data.recentRecords, data.todayInterruptions);
          setSpreadsheetLink(data.spreadsheetUrl);
          DateSelector.init();
          DateSelector.loadWeekCounts();
          MemoSidebar.init(data.memos, data.memoTags);

          restoreTimer();
          updateDisplay();
          updateControls();
        })
        .catch(function (err) {
          console.error("Init failed:", err);
          updateDisplay();
          updateControls();
        })
        .finally(function () {
          showLoading(false);
          TabPanel.init();
          var memoActiveId = localStorage.getItem("gas_pomodoro_memo_active") || "";
          var memoInitContent = memoActiveId ? (localStorage.getItem("gas_pomodoro_memo_" + memoActiveId) || "") : "";
          MemoEditor.init(memoInitContent).then(function () {
            MemoSidebar.initAfterEditorMount();
          }).catch(function (err) {
            console.error("MemoEditor init failed:", err);
            MemoSidebar.initAfterEditorMount();
          });
        });
    }

    return {
      init: init,
      startWork: startWork,
      completeBreak: completeBreak,
      startInterruption: startInterruption,
      endInterruption: endInterruption,
      discardInterruption: discardInterruption,
      onRecordSaved: onRecordSaved,
      startNextWork: startNextWork,
      endWorkSession: endWorkSession,
      continueWork: continueWork,
      endSession: endSession,
      onPatternChange: onPatternChange,
      getState: getState,
      getInterruptionCategories: getInterruptionCategories,
      ensureInterruptionCategory: ensureInterruptionCategory,
    };
  })();

  // --- Stats & History Display ---
  function formatDuration(totalSeconds) {
    var totalMins = Math.floor(totalSeconds / 60);
    var hours = Math.floor(totalMins / 60);
    var mins = totalMins % 60;
    if (hours > 0) return hours + "時間" + mins + "分";
    return mins + "分";
  }

  function displayStats(stats) {
    var s = stats || {
      completedPomodoros: 0,
      abandonedPomodoros: 0,
      totalWorkSeconds: 0,
      totalBreakSeconds: 0,
      totalWorkInterruptionSeconds: 0,
      totalNonWorkInterruptionSeconds: 0,
    };
    document.getElementById("stats-pomodoros").textContent =
      s.completedPomodoros.toString();
    var abandonedEl = document.getElementById("stats-abandoned");
    abandonedEl.textContent =
      s.abandonedPomodoros > 0 ? " / " + s.abandonedPomodoros : "";
    document.getElementById("stats-work-time").textContent = formatDuration(
      s.totalWorkSeconds,
    );
    document.getElementById("stats-break-time").textContent = formatDuration(
      s.totalBreakSeconds,
    );
    document.getElementById("stats-work-int-time").textContent = formatDuration(
      s.totalWorkInterruptionSeconds,
    );
    document.getElementById("stats-nonwork-int-time").textContent =
      formatDuration(s.totalNonWorkInterruptionSeconds);
  }

  function displayHistory(records, interruptions) {
    var list = document.getElementById("history-list");
    list.innerHTML = "";

    if (!records || records.length === 0) {
      list.innerHTML = '<li class="history-empty">まだ記録がありません</li>';
      return;
    }

    // Build category color map
    var state = App.getState();
    var colorMap = {};
    if (state.categories) {
      state.categories.forEach(function (c) {
        colorMap[c.name] = c.color;
      });
    }

    // Group interruptions by pomodoroId
    var intMap = {};
    if (interruptions) {
      interruptions.forEach(function (i) {
        if (!intMap[i.pomodoroId]) intMap[i.pomodoroId] = [];
        intMap[i.pomodoroId].push(i);
      });
    }

    var fragment = document.createDocumentFragment();

    records.forEach(function (r) {
      if (r.type !== "work") return;
      var li = document.createElement("li");
      li.className = "history-item";

      var row = document.createElement("div");
      row.className = "history-item-row";

      // Category dot with color
      var dot = document.createElement("span");
      dot.className = "history-type";
      var catColor = r.category && colorMap[r.category];
      dot.style.background = catColor || "var(--text-secondary)";

      // Category name
      var cat = document.createElement("span");
      cat.className = "history-category";
      cat.textContent = r.category || "";
      if (catColor) cat.style.color = catColor;

      // Description (first line only)
      var desc = document.createElement("span");
      desc.className = "history-desc";
      var firstLine = (r.description || "").split("\n")[0].trim();
      desc.textContent = firstLine || "(無題)";

      // Meta: start time + duration/interruptions
      var meta = document.createElement("span");
      meta.className = "history-meta";
      var metaParts = [];
      try {
        var d = new Date(r.startTime);
        metaParts.push(
          String(d.getHours()).padStart(2, "0") +
            ":" +
            String(d.getMinutes()).padStart(2, "0"),
        );
      } catch (e) {}
      var durMin = Math.floor(r.actualDurationSeconds / 60);
      var intCount = r.workInterruptions + r.nonWorkInterruptions;
      metaParts.push(
        durMin + "分" + (intCount > 0 ? "/" + intCount + "中断" : ""),
      );
      meta.textContent = metaParts.join(" ");

      row.appendChild(dot);
      row.appendChild(cat);
      row.appendChild(desc);
      row.appendChild(meta);
      li.appendChild(row);

      // Click handler: open viewer with description
      (function (record, metaText) {
        row.addEventListener("click", function () {
          var description = (record.description || "").trim();
          var title = (record.description || "").split("\n")[0].trim() || "(無題)";
          // Add start time to viewer meta
          var viewerMeta = metaText;
          try {
            var st = new Date(record.startTime);
            viewerMeta = String(st.getHours()).padStart(2, "0") + ":" +
              String(st.getMinutes()).padStart(2, "0") + " 開始 - " + metaText;
          } catch (e) {}
          TabPanel.showViewer(title, viewerMeta, description, record.id, "record", {
            category: record.category || "",
            sheetType: "Categories",
          });
        });
      })(r, metaParts.join(" "));

      // Interruption detail (always visible inline)
      var recordInts = intMap[r.id];
      if (recordInts && recordInts.length > 0) {
        var detail = document.createElement("div");
        detail.className = "history-detail";

        recordInts.forEach(function (int) {
          var intRow = document.createElement("div");
          intRow.className = "history-detail-row";

          var typeLabel = int.type === "work" ? "作業" : "非作業";
          var intMins = Math.floor(int.durationSeconds / 60);
          var intSecs = int.durationSeconds % 60;
          var durStr =
            intMins > 0
              ? intMins + "分" + (intSecs > 0 ? intSecs + "秒" : "")
              : intSecs + "秒";

          // Dot with interruption category color
          var intDot = document.createElement("span");
          intDot.className = "history-type";
          var intCatObj = int.category ? state.interruptionCategories.find(function (c) {
            return c.name === int.category;
          }) : null;
          intDot.style.background = (intCatObj && intCatObj.color) || "var(--text-secondary)";

          // Category name
          var intCat = document.createElement("span");
          intCat.className = "history-category";
          intCat.textContent = int.category || "";
          if (intCatObj && intCatObj.color) intCat.style.color = intCatObj.color;

          // Note (first line)
          var intDesc = document.createElement("span");
          intDesc.className = "history-desc";
          var intFirstLine = (int.note || "").split("\n")[0].trim();
          intDesc.textContent = intFirstLine || "(中断)";

          // Meta: start time + duration/type
          var intMeta = document.createElement("span");
          intMeta.className = "history-meta";
          var intMetaParts = [];
          try {
            var intD = new Date(int.startTime);
            intMetaParts.push(
              String(intD.getHours()).padStart(2, "0") + ":" +
              String(intD.getMinutes()).padStart(2, "0")
            );
          } catch (e) {}
          intMetaParts.push(durStr + "/" + typeLabel);
          intMeta.textContent = intMetaParts.join(" ");

          intRow.appendChild(intDot);
          intRow.appendChild(intCat);
          intRow.appendChild(intDesc);
          intRow.appendChild(intMeta);

          // Click handler: open viewer with interruption note
          (function (interruption, intDurStr) {
            intRow.addEventListener("click", function (e) {
              e.stopPropagation();
              var note = (interruption.note || "").trim();
              var noteTitle = (note ? note.split("\n")[0].trim() : "") || "中断";
              var intMetaText = (interruption.type === "work" ? "作業" : "非作業") + " - " + intDurStr;
              if (interruption.category) intMetaText += " - " + interruption.category;
              TabPanel.showViewer(noteTitle, intMetaText, note, interruption.id, "interruption", {
                category: interruption.category || "",
                sheetType: "InterruptionCategories",
                interruptionType: interruption.type,
              });
            });
          })(int, durStr);

          detail.appendChild(intRow);
        });

        li.appendChild(detail);
      }

      fragment.appendChild(li);
    });

    if (fragment.children.length === 0) {
      list.innerHTML = '<li class="history-empty">まだ記録がありません</li>';
    } else {
      list.appendChild(fragment);
    }
  }

  function setSpreadsheetLink(url) {
    var link = document.getElementById("spreadsheet-link");
    if (link && url) {
      link.href = url;
      link.style.display = "";
    }
  }

  function refreshAll() {
    DateSelector.onRecordSaved();
  }

  // --- Boot ---
  document.addEventListener("DOMContentLoaded", App.init);
</script>
