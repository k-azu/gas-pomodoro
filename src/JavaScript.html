<script>
  // --- Utility: Promise wrapper for google.script.run ---
  function serverCall(functionName) {
    var args = Array.prototype.slice.call(arguments, 1);
    return new Promise(function (resolve, reject) {
      var runner = google.script.run
        .withSuccessHandler(resolve)
        .withFailureHandler(reject);
      runner[functionName].apply(runner, args);
    });
  }

  function showLoading(show) {
    var el = document.getElementById("loading-overlay");
    if (show) el.classList.add("visible");
    else el.classList.remove("visible");
  }

  // --- App State & Timer Engine ---
  var App = (function () {
    var STORAGE_KEY = "gas_pomodoro_state";

    // Default state
    var state = {
      phase: "idle", // idle | work | interrupted | recording | abandoning | shortBreak | longBreak | breakDone
      breakType: null, // 'shortBreak' | 'longBreak' — remembers which break just ended
      remainingSeconds: 0,
      startTimestamp: null, // wall-clock start time (ms)
      totalSeconds: 0, // total duration for current timer
      pomodoroSetIndex: 1, // 1-4
      interruptions: [], // array of { id, type, startTime, endTime, durationSeconds, category, note }
      currentInterruption: null, // { id, type, startTimestamp } while interrupted
      interruptionElapsed: 0, // total ms spent in interruptions (for timer calc)
      config: {
        patternName: "Standard",
        workMinutes: 25,
        shortBreakMinutes: 5,
        longBreakMinutes: 15,
        pomodorosBeforeLongBreak: 4,
      },
      configPatterns: [],
      categories: [],
      interruptionCategories: [],
    };

    var timerInterval = null;

    // --- localStorage persistence ---
    function saveState() {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      } catch (e) {}
    }

    function loadState() {
      try {
        var saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
          var parsed = JSON.parse(saved);
          Object.keys(parsed).forEach(function (k) {
            if (k === "config") {
              Object.assign(state.config, parsed.config);
            } else {
              state[k] = parsed[k];
            }
          });
        }
      } catch (e) {}
    }

    function clearState() {
      state.phase = "idle";
      state.breakType = null;
      state.remainingSeconds = 0;
      state.startTimestamp = null;
      state.totalSeconds = 0;
      state.pomodoroSetIndex = 1;

      state.interruptions = [];
      state.currentInterruption = null;
      state.interruptionElapsed = 0;
      saveState();
    }

    // --- Timer Core ---
    function tick() {
      var now = Date.now();

      if (state.phase === "interrupted") {
        // Show interruption elapsed time (count up)
        var intStart = state.currentInterruption.startTimestamp;
        var intElapsed = Math.floor((now - intStart) / 1000);
        updateInterruptionTimerDisplay(intElapsed);
        return;
      }

      // Wall-clock calculation for work/break timer
      var elapsed = now - state.startTimestamp - state.interruptionElapsed;
      var elapsedSeconds = Math.floor(elapsed / 1000);
      state.remainingSeconds = Math.max(0, state.totalSeconds - elapsedSeconds);

      updateDisplay();
      saveState();

      if (state.remainingSeconds <= 0) {
        onTimerComplete();
      }
    }

    function startTimer(phase, durationMinutes) {
      state.phase = phase;
      state.totalSeconds = durationMinutes * 60;
      state.remainingSeconds = state.totalSeconds;
      state.startTimestamp = Date.now();
      state.interruptionElapsed = 0;

      if (phase === "work") {
        state.interruptions = [];
        state.currentInterruption = null;
        // Clear form for new pomodoro
        MemoEditor.clearRecord();
        var recCat = document.getElementById("record-category");
        if (recCat) recCat.selectedIndex = 0;
      }

      saveState();
      updateDisplay();
      updateControls();
      startInterval();
    }

    function startInterval() {
      stopInterval();
      timerInterval = setInterval(tick, 250);
    }

    function stopInterval() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
    }

    // --- Interruption: start/end ---
    function startInterruption() {
      if (state.phase !== "work") return;

      var id = RecordForm.generateUUID();
      state.currentInterruption = {
        id: id,
        startTimestamp: Date.now(),
      };
      state.phase = "interrupted";

      // Reset form fields
      var radios = document.querySelectorAll('input[name="int-type"]');
      radios.forEach(function (r) {
        r.checked = r.value === "nonWork";
      });
      MemoEditor.clearInterruption();
      populateInterruptionCategorySelect();

      saveState();
      updateDisplay();
      updateControls();
    }

    function populateInterruptionCategorySelect() {
      var select = document.getElementById("int-category");
      select.innerHTML = '<option value="">-- カテゴリ --</option>';
      state.interruptionCategories.forEach(function (c) {
        var opt = document.createElement("option");
        opt.value = c.name;
        opt.textContent = c.name;
        select.appendChild(opt);
      });
    }

    function endInterruption() {
      if (state.phase !== "interrupted" || !state.currentInterruption) return;

      var now = Date.now();
      var durationMs = now - state.currentInterruption.startTimestamp;
      var durationSeconds = Math.round(durationMs / 1000);

      // Read form values
      var typeRadio = document.querySelector('input[name="int-type"]:checked');
      var type = typeRadio ? typeRadio.value : "nonWork";
      var category = document.getElementById("int-category").value;
      var note = (MemoEditor.getInterruptionValue() || "").trim();

      state.interruptions.push({
        id: state.currentInterruption.id,
        type: type,
        startTime: new Date(
          state.currentInterruption.startTimestamp,
        ).toISOString(),
        endTime: new Date(now).toISOString(),
        durationSeconds: durationSeconds,
        category: category,
        note: note,
      });

      state.interruptionElapsed += durationMs;
      state.currentInterruption = null;
      state.phase = "work";
      saveState();
      updateDisplay();
      updateControls();
    }

    function abandon() {
      // If currently interrupted, finalize that interruption first
      if (state.phase === "interrupted" && state.currentInterruption) {
        var now = Date.now();
        var durationMs = now - state.currentInterruption.startTimestamp;
        var typeRadio = document.querySelector(
          'input[name="int-type"]:checked',
        );
        var intType = typeRadio ? typeRadio.value : "nonWork";
        var intCategory = document.getElementById("int-category").value;
        var intNote = (MemoEditor.getInterruptionValue() || "").trim();
        state.interruptions.push({
          id: state.currentInterruption.id,
          type: intType,
          startTime: new Date(
            state.currentInterruption.startTimestamp,
          ).toISOString(),
          endTime: new Date(now).toISOString(),
          durationSeconds: Math.round(durationMs / 1000),
          category: intCategory,
          note: intNote,
        });
        state.interruptionElapsed += durationMs;
        state.currentInterruption = null;
      }

      if (state.phase === "work" || state.phase === "interrupted") {
        stopInterval();

        state.phase = "abandoning";
        saveState();
        updateDisplay();
        updateControls();
      }
    }

    function skipBreak() {
      if (state.phase !== "shortBreak" && state.phase !== "longBreak") return;
      stopInterval();
      state.breakType = state.phase;
      state.phase = "breakDone";
      saveState();
      updateDisplay();
      updateControls();
    }

    function onAbandonRecorded(resetSet) {
      if (resetSet) {
        clearState();
      } else {
        // Keep pomodoroSetIndex, just go idle
        state.phase = "idle";
        state.breakType = null;
        state.remainingSeconds = 0;
        state.startTimestamp = null;
        state.totalSeconds = 0;

        state.interruptions = [];
        state.currentInterruption = null;
        state.interruptionElapsed = 0;
        saveState();
      }
      updateDisplay();
      updateControls();
      refreshHistory();
      refreshStats();
    }

    function onTimerComplete() {
      stopInterval();

      if (state.phase === "work") {
        NotificationManager.notify(
          "作業完了",
          "ポモドーロが終了しました。記録を入力してください。",
        );

        state.phase = "recording";
        saveState();
        updateDisplay();
        updateControls();
      } else if (state.phase === "shortBreak" || state.phase === "longBreak") {
        NotificationManager.notify(
          "休憩終了",
          "休憩が終わりました。次のポモドーロを始めましょう。",
        );
        state.breakType = state.phase;
        state.phase = "breakDone";
        saveState();
        updateDisplay();
        updateControls();
      }
    }

    function saveBreakRecord() {
      var now = new Date();
      var startTime = new Date(state.startTimestamp);
      var durationSeconds =
        (state.breakType === "shortBreak"
          ? state.config.shortBreakMinutes
          : state.config.longBreakMinutes) * 60;
      var record = {
        id: RecordForm.generateUUID(),
        date: RecordForm.formatDate(now),
        startTime: startTime.toISOString(),
        endTime: now.toISOString(),
        durationSeconds: durationSeconds,
        actualDurationSeconds: Math.round(
          (now.getTime() - startTime.getTime()) / 1000,
        ),
        type: state.breakType,
        description: "",
        category: "",
        workInterruptions: 0,
        nonWorkInterruptions: 0,
        workInterruptionSeconds: 0,
        nonWorkInterruptionSeconds: 0,
        completionStatus: "completed",
        pomodoroSetIndex: state.pomodoroSetIndex,
      };
      return serverCall("saveRecord", record);
    }

    function continueWork() {
      if (state.phase !== "breakDone") return;
      saveBreakRecord().then(function () {
        refreshHistory();
        refreshStats();
        startTimer("work", state.config.workMinutes);
      });
    }

    function endSession() {
      if (state.phase !== "breakDone") return;
      saveBreakRecord().then(function () {
        clearState();
        updateDisplay();
        updateControls();
        refreshHistory();
        refreshStats();
      });
    }

    // Called after record form submission
    function onRecordSaved() {
      var limit = state.config.pomodorosBeforeLongBreak;
      var isLongBreak = state.pomodoroSetIndex >= limit;

      if (isLongBreak) {
        state.pomodoroSetIndex = 1;
        startTimer("longBreak", state.config.longBreakMinutes);
      } else {
        state.pomodoroSetIndex++;
        startTimer("shortBreak", state.config.shortBreakMinutes);
      }
    }

    function startWork() {
      startTimer("work", state.config.workMinutes);
    }

    function onPatternChange(patternName) {
      var pattern = state.configPatterns.find(function (p) {
        return p.patternName === patternName;
      });
      if (!pattern) return;
      state.config = pattern;
      saveState();
      updateDisplay();
      updateDots();
    }

    // --- UI Update ---
    function updateDisplay() {
      var mins = Math.floor(state.remainingSeconds / 60);
      var secs = state.remainingSeconds % 60;

      document.getElementById("timer-display").textContent =
        String(mins).padStart(2, "0") + ":" + String(secs).padStart(2, "0");

      // Phase label
      var labels = {
        idle: "準備完了",
        work: "作業中",
        interrupted: "中断中",
        recording: "記録中",
        abandoning: "中止 - 記録中",
        shortBreak: "短い休憩",
        longBreak: "長い休憩",
        breakDone: "休憩終了",
      };
      document.getElementById("phase-label").textContent =
        labels[state.phase] || "";

      // Timer card data attribute for styling
      var card = document.getElementById("timer-card");
      var dataPhase = state.phase;
      if (dataPhase === "recording" || dataPhase === "abandoning")
        dataPhase = "work";
      if (dataPhase === "breakDone")
        dataPhase = state.breakType || "shortBreak";
      card.setAttribute("data-phase", dataPhase);

      updateDots();
      updateInterruptionBadge();
    }

    function updateInterruptionTimerDisplay(elapsedSeconds) {
      var mins = Math.floor(elapsedSeconds / 60);
      var secs = elapsedSeconds % 60;
      var el = document.getElementById("interruption-timer");
      if (el) {
        el.textContent =
          String(mins).padStart(2, "0") + ":" + String(secs).padStart(2, "0");
      }
    }

    function updateDots() {
      var limit = state.config.pomodorosBeforeLongBreak;
      var container = document.getElementById("pomodoro-dots");
      container.innerHTML = "";
      for (var i = 1; i <= limit; i++) {
        var dot = document.createElement("div");
        dot.className = "pomodoro-dot";
        if (i < state.pomodoroSetIndex) {
          dot.classList.add("completed");
        } else if (
          i === state.pomodoroSetIndex &&
          (state.phase === "work" || state.phase === "interrupted")
        ) {
          dot.classList.add("current");
        }
        container.appendChild(dot);
      }
    }

    function updateControls() {
      var startBtn = document.getElementById("btn-start");
      var interruptionControls = document.getElementById(
        "interruption-controls",
      );
      var breakAbortControls = document.getElementById("break-abort-controls");
      var breakDonePanel = document.getElementById("break-done-panel");

      var isIdle = state.phase === "idle";
      var isWork = state.phase === "work";
      var isInterrupted = state.phase === "interrupted";
      var isRecording = state.phase === "recording";
      var isBreakDone = state.phase === "breakDone";
      var isAbandoning = state.phase === "abandoning";
      var isBreak = state.phase === "shortBreak" || state.phase === "longBreak";

      // Timer card buttons
      startBtn.style.display = isIdle ? "" : "none";
      interruptionControls.style.display = isWork ? "" : "none";
      breakAbortControls.style.display = isBreak ? "" : "none";
      breakDonePanel.style.display = isBreakDone ? "" : "none";

      // Record form actions (in right panel record tab)
      var actionsWork = document.getElementById("record-form-actions-work");
      var actionsNormal = document.getElementById("record-form-actions-normal");
      var actionsAbandon = document.getElementById(
        "record-form-actions-abandon",
      );

      actionsWork.style.display = isWork ? "" : "none";
      actionsNormal.style.display = isRecording ? "" : "none";
      actionsAbandon.style.display = isAbandoning ? "" : "none";

      var showForm = isWork || isInterrupted || isRecording || isAbandoning;
      if (showForm) {
        RecordForm.renderInterruptionList();
      }

      // Update tab panel
      TabPanel.update(state.phase);

      updatePatternInfo();
    }

    function updateInterruptionBadge() {
      var count = state.interruptions.length;
      var badge = document.getElementById("interruption-badge");
      if (count > 0) {
        badge.textContent = count + "件の中断";
        badge.style.display = "";
      } else {
        badge.style.display = "none";
      }
    }

    function populatePatternSelect() {
      var select = document.getElementById("pattern-select");
      select.innerHTML = "";
      state.configPatterns.forEach(function (p) {
        var opt = document.createElement("option");
        opt.value = p.patternName;
        opt.textContent =
          p.patternName +
          "  (" +
          p.workMinutes +
          "/" +
          p.shortBreakMinutes +
          "/" +
          p.longBreakMinutes +
          ")";
        if (p.patternName === state.config.patternName) opt.selected = true;
        select.appendChild(opt);
      });
    }

    function updatePatternInfo() {
      var selector = document.getElementById("pattern-selector");
      if (!selector) return;

      // Show when idle and multiple patterns exist
      var visible = state.phase === "idle" && state.configPatterns.length > 1;
      selector.style.display = visible ? "" : "none";

      var select = document.getElementById("pattern-select");
      select.disabled = state.phase !== "idle";
      select.value = state.config.patternName;
    }

    function getState() {
      return state;
    }

    function getInterruptionCategories() {
      return state.interruptionCategories;
    }

    // --- Restore from localStorage on page load ---
    function restoreTimer() {
      if (
        state.phase === "idle" ||
        state.phase === "recording" ||
        state.phase === "breakDone" ||
        state.phase === "abandoning"
      )
        return;

      if (state.phase === "interrupted") {
        // Restore interrupted state
        updateDisplay();
        updateControls();
        startInterval();
        return;
      }

      // Wall-clock recovery
      var now = Date.now();
      var elapsed = now - state.startTimestamp - state.interruptionElapsed;
      var elapsedSeconds = Math.floor(elapsed / 1000);
      state.remainingSeconds = Math.max(0, state.totalSeconds - elapsedSeconds);

      if (state.remainingSeconds <= 0) {
        onTimerComplete();
      } else {
        updateDisplay();
        updateControls();
        startInterval();
      }
    }

    // --- Init ---
    function init() {
      loadState();
      showLoading(true);

      Promise.all([
        serverCall("getAllTimerConfigs"),
        serverCall("getCategories"),
        serverCall("getInterruptionCategories"),
        serverCall("getTodayStats"),
        serverCall("getRecentRecords", 10),
        serverCall("getSpreadsheetUrl"),
        serverCall("getTodayInterruptions"),
      ])
        .then(function (results) {
          state.configPatterns = results[0];
          // Use saved pattern name from localStorage, or fall back to first pattern
          var savedName = state.config.patternName;
          var match = state.configPatterns.find(function (p) {
            return p.patternName === savedName;
          });
          if (match) {
            state.config = match;
          } else {
            state.config = state.configPatterns[0];
          }
          state.categories = results[1];
          state.interruptionCategories = results[2];
          populatePatternSelect();
          RecordForm.populateCategories(results[1]);
          displayStats(results[3]);
          displayHistory(results[4], results[6]);
          setSpreadsheetLink(results[5]);

          restoreTimer();
          updateDisplay();
          updateControls();
        })
        .catch(function (err) {
          console.error("Init failed:", err);
          updateDisplay();
          updateControls();
        })
        .finally(function () {
          showLoading(false);
          TabPanel.init();
          MemoEditor.init();
        });
    }

    return {
      init: init,
      startWork: startWork,
      abandon: abandon,
      skipBreak: skipBreak,
      startInterruption: startInterruption,
      endInterruption: endInterruption,
      onRecordSaved: onRecordSaved,
      onAbandonRecorded: onAbandonRecorded,
      continueWork: continueWork,
      endSession: endSession,
      onPatternChange: onPatternChange,
      getState: getState,
      getInterruptionCategories: getInterruptionCategories,
    };
  })();

  // --- Stats & History Display ---
  function formatDuration(totalSeconds) {
    var totalMins = Math.floor(totalSeconds / 60);
    var hours = Math.floor(totalMins / 60);
    var mins = totalMins % 60;
    if (hours > 0) return hours + "時間" + mins + "分";
    return mins + "分";
  }

  function displayStats(stats) {
    var s = stats || {
      completedPomodoros: 0,
      abandonedPomodoros: 0,
      totalWorkSeconds: 0,
      totalBreakSeconds: 0,
      totalWorkInterruptionSeconds: 0,
      totalNonWorkInterruptionSeconds: 0,
    };
    document.getElementById("stats-pomodoros").textContent =
      s.completedPomodoros.toString();
    var abandonedEl = document.getElementById("stats-abandoned");
    abandonedEl.textContent =
      s.abandonedPomodoros > 0 ? " / " + s.abandonedPomodoros : "";
    document.getElementById("stats-work-time").textContent = formatDuration(
      s.totalWorkSeconds,
    );
    document.getElementById("stats-break-time").textContent = formatDuration(
      s.totalBreakSeconds,
    );
    document.getElementById("stats-work-int-time").textContent = formatDuration(
      s.totalWorkInterruptionSeconds,
    );
    document.getElementById("stats-nonwork-int-time").textContent =
      formatDuration(s.totalNonWorkInterruptionSeconds);
  }

  function displayHistory(records, interruptions) {
    var list = document.getElementById("history-list");
    list.innerHTML = "";

    if (!records || records.length === 0) {
      list.innerHTML = '<li class="history-empty">まだ記録がありません</li>';
      return;
    }

    // Build category color map
    var state = App.getState();
    var colorMap = {};
    if (state.categories) {
      state.categories.forEach(function (c) {
        colorMap[c.name] = c.color;
      });
    }

    // Group interruptions by pomodoroId
    var intMap = {};
    if (interruptions) {
      interruptions.forEach(function (i) {
        if (!intMap[i.pomodoroId]) intMap[i.pomodoroId] = [];
        intMap[i.pomodoroId].push(i);
      });
    }

    records.forEach(function (r) {
      if (r.type !== "work") return;
      var li = document.createElement("li");
      li.className = "history-item";

      var row = document.createElement("div");
      row.className = "history-item-row";

      // Category dot with color
      var dot = document.createElement("span");
      dot.className = "history-type";
      var catColor = r.category && colorMap[r.category];
      dot.style.background = catColor || "var(--text-secondary)";

      // Category name
      var cat = document.createElement("span");
      cat.className = "history-category";
      cat.textContent = r.category || "";
      if (catColor) cat.style.color = catColor;

      // Description (first line only)
      var desc = document.createElement("span");
      desc.className = "history-desc";
      var firstLine = (r.description || "").split("\n")[0].trim();
      desc.textContent = firstLine || "(無題)";

      // Meta: start time + duration/interruptions
      var meta = document.createElement("span");
      meta.className = "history-meta";
      var metaParts = [];
      try {
        var d = new Date(r.startTime);
        metaParts.push(
          String(d.getHours()).padStart(2, "0") +
            ":" +
            String(d.getMinutes()).padStart(2, "0"),
        );
      } catch (e) {}
      var durMin = Math.floor(r.actualDurationSeconds / 60);
      var intCount = r.workInterruptions + r.nonWorkInterruptions;
      metaParts.push(
        durMin + "分" + (intCount > 0 ? "/" + intCount + "中断" : ""),
      );
      meta.textContent = metaParts.join(" ");

      row.appendChild(dot);
      row.appendChild(cat);
      row.appendChild(desc);
      row.appendChild(meta);
      li.appendChild(row);

      // Click handler: open viewer with description
      (function (record, metaText) {
        row.addEventListener("click", function () {
          var description = (record.description || "").trim();
          if (!description) return;
          var title = (record.description || "").split("\n")[0].trim() || "(無題)";
          // Add start time to viewer meta
          var viewerMeta = metaText;
          try {
            var st = new Date(record.startTime);
            viewerMeta = String(st.getHours()).padStart(2, "0") + ":" +
              String(st.getMinutes()).padStart(2, "0") + " 開始 - " + metaText;
          } catch (e) {}
          TabPanel.showViewer(title, viewerMeta, description, record.id, "record");
        });
      })(r, metaParts.join(" "));

      // Interruption detail (always visible inline)
      var recordInts = intMap[r.id];
      if (recordInts && recordInts.length > 0) {
        var detail = document.createElement("div");
        detail.className = "history-detail";

        recordInts.forEach(function (int) {
          var intRow = document.createElement("div");
          intRow.className = "history-detail-row";

          var typeLabel = int.type === "work" ? "作業" : "非作業";
          var intMins = Math.floor(int.durationSeconds / 60);
          var intSecs = int.durationSeconds % 60;
          var durStr =
            intMins > 0
              ? intMins + "分" + (intSecs > 0 ? intSecs + "秒" : "")
              : intSecs + "秒";

          intRow.textContent = typeLabel + " - " + durStr;
          if (int.category) {
            var intCatSpan = document.createElement("span");
            intCatSpan.textContent = " - " + int.category;
            var intCatObj = state.interruptionCategories.find(function (c) {
              return c.name === int.category;
            });
            if (intCatObj && intCatObj.color)
              intCatSpan.style.color = intCatObj.color;
            intRow.appendChild(intCatSpan);
          }
          if (int.note) {
            var noteSpan = document.createTextNode(
              " - " + int.note.split("\n")[0],
            );
            intRow.appendChild(noteSpan);
          }

          // Click handler: open viewer with interruption note
          (function (interruption, intDurStr) {
            intRow.addEventListener("click", function (e) {
              e.stopPropagation();
              var note = (interruption.note || "").trim();
              if (!note) return;
              var noteTitle = note.split("\n")[0].trim();
              var intMetaText = (interruption.type === "work" ? "作業" : "非作業") + " - " + intDurStr;
              if (interruption.category) intMetaText += " - " + interruption.category;
              TabPanel.showViewer(noteTitle, intMetaText, note, interruption.id, "interruption");
            });
          })(int, durStr);

          detail.appendChild(intRow);
        });

        li.appendChild(detail);
      }

      list.appendChild(li);
    });

    if (list.children.length === 0) {
      list.innerHTML = '<li class="history-empty">まだ記録がありません</li>';
    }
  }

  function setSpreadsheetLink(url) {
    var link = document.getElementById("spreadsheet-link");
    if (link && url) {
      link.href = url;
      link.style.display = "";
    }
  }

  function refreshHistory() {
    Promise.all([
      serverCall("getRecentRecords", 10),
      serverCall("getTodayInterruptions"),
    ]).then(function (results) {
      displayHistory(results[0], results[1]);
    });
  }

  function refreshStats() {
    serverCall("getTodayStats").then(displayStats);
  }

  // --- Boot ---
  document.addEventListener("DOMContentLoaded", App.init);
</script>
