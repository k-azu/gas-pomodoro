<script>
  var TaskStore = (function () {
    var DB_NAME = "gas_pomodoro";
    var DB_VERSION = 1;
    var _db = null;
    var _listeners = {};
    var _entityStoreMap = {};
    var _serverQueues = {};
    var _metaDebounces = {};
    var _contentSyncDebounces = {};
    var _reorderState = {
      projects: { pending: null, saving: false },
      cases: { pending: null, saving: false },
      tasks: { pending: null, saving: false }
    };
    var _reorderDebounces = {};

    // =========================================================
    // Per-ID operation lock (serializes read-modify-write)
    // =========================================================
    var _pendingOps = {};
    function withLock(id, fn) {
      var prev = _pendingOps[id] || Promise.resolve();
      var next = prev.then(fn, fn);
      _pendingOps[id] = next;
      next.then(function () {
        if (_pendingOps[id] === next) delete _pendingOps[id];
      });
      return next;
    }

    // =========================================================
    // IndexedDB Setup
    // =========================================================
    function openDB() {
      if (_db) return Promise.resolve(_db);
      return new Promise(function (resolve, reject) {
        var req;
        try {
          req = indexedDB.open(DB_NAME, DB_VERSION);
        } catch (e) {
          console.error("[TaskStore] indexedDB.open threw:", e);
          reject(e);
          return;
        }
        req.onupgradeneeded = function () {
          var db = req.result;
          if (!db.objectStoreNames.contains("projects")) {
            db.createObjectStore("projects", { keyPath: "id" });
          }
          if (!db.objectStoreNames.contains("cases")) {
            var cs = db.createObjectStore("cases", { keyPath: "id" });
            cs.createIndex("projectId", "projectId", { unique: false });
          }
          if (!db.objectStoreNames.contains("tasks")) {
            var ts = db.createObjectStore("tasks", { keyPath: "id" });
            ts.createIndex("projectId", "projectId", { unique: false });
            ts.createIndex("caseId", "caseId", { unique: false });
            ts.createIndex("status", "status", { unique: false });
          }
          if (!db.objectStoreNames.contains("contents")) {
            db.createObjectStore("contents", { keyPath: "id" });
          }
          if (!db.objectStoreNames.contains("syncMeta")) {
            db.createObjectStore("syncMeta", { keyPath: "key" });
          }
        };
        req.onsuccess = function () {
          _db = req.result;
          console.log("[TaskStore] IndexedDB opened successfully");
          resolve(_db);
        };
        req.onerror = function () {
          console.error("[TaskStore] IndexedDB open failed:", req.error);
          reject(req.error);
        };
        req.onblocked = function () {
          console.warn("[TaskStore] IndexedDB open blocked (another connection open?)");
        };
      });
    }

    // =========================================================
    // Core DB functions
    // =========================================================
    function getAll(storeName) {
      return openDB().then(function (db) {
        return new Promise(function (resolve, reject) {
          var tx = db.transaction(storeName, "readonly");
          var req = tx.objectStore(storeName).getAll();
          req.onsuccess = function () { resolve(req.result); };
          req.onerror = function () { reject(req.error); };
        });
      });
    }

    function get(storeName, id) {
      return openDB().then(function (db) {
        return new Promise(function (resolve, reject) {
          var tx = db.transaction(storeName, "readonly");
          var req = tx.objectStore(storeName).get(id);
          req.onsuccess = function () { resolve(req.result || null); };
          req.onerror = function () {
            console.error("[TaskStore] get failed:", storeName, id, req.error);
            reject(req.error);
          };
        });
      });
    }

    /** Lock-free direct read (alias for get, intent-revealing name) */
    var rawGet = get;

    function put(storeName, data) {
      return openDB().then(function (db) {
        return new Promise(function (resolve, reject) {
          var tx = db.transaction(storeName, "readwrite");
          tx.objectStore(storeName).put(data);
          tx.oncomplete = function () { resolve(); };
          tx.onerror = function () {
            console.error("[TaskStore] put failed:", storeName, data && data.id, tx.error);
            reject(tx.error);
          };
        });
      });
    }

    function remove(storeName, id) {
      return openDB().then(function (db) {
        return new Promise(function (resolve, reject) {
          var tx = db.transaction(storeName, "readwrite");
          tx.objectStore(storeName).delete(id);
          tx.oncomplete = function () { resolve(); };
          tx.onerror = function () { reject(tx.error); };
        });
      });
    }

    function getByIndex(storeName, indexName, val) {
      return openDB().then(function (db) {
        return new Promise(function (resolve, reject) {
          var tx = db.transaction(storeName, "readonly");
          var idx = tx.objectStore(storeName).index(indexName);
          var req = idx.getAll(val);
          req.onsuccess = function () { resolve(req.result); };
          req.onerror = function () { reject(req.error); };
        });
      });
    }

    // =========================================================
    // Generic update helpers (withLock-based)
    // =========================================================
    function updateEntity(storeName, id, mergeFn) {
      return withLock(id, function () {
        return get(storeName, id).then(function (item) {
          if (!item) return;
          mergeFn(item);
          return put(storeName, item);
        });
      });
    }

    function updateSortOrders(storeName, entries) {
      return Promise.all(entries.map(function (e) {
        _entityStoreMap[e.id] = storeName;
        return withLock(e.id, function () {
          return get(storeName, e.id).then(function (item) {
            if (!item) return;
            item.sortOrder = e.sortOrder;
            item._dirty = true;
            return put(storeName, item);
          });
        }).catch(function (err) {
          console.error("[TaskStore] updateSortOrders partial failure:", e.id, err);
        });
      }));
    }

    // =========================================================
    // Event System
    // =========================================================
    function on(event, cb) {
      if (!_listeners[event]) _listeners[event] = [];
      _listeners[event].push(cb);
    }

    function emit(event, data) {
      var cbs = _listeners[event] || [];
      cbs.forEach(function (cb) {
        try { cb(data); } catch (e) { console.error("TaskStore event error:", e); }
      });
    }

    // =========================================================
    // UUID generation
    // =========================================================
    function generateUUID() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
        var r = (Math.random() * 16) | 0;
        return (c === "x" ? r : (r & 0x3) | 0x8).toString(16);
      });
    }

    // =========================================================
    // CRUD Operations
    // =========================================================
    function addProject(name, color) {
      var id = generateUUID();
      var now = new Date().toISOString();
      var item = {
        id: id,
        name: name,
        color: color || "#4285f4",
        sortOrder: Date.now(),
        isActive: true,
        createdAt: now,
        updatedAt: now,
        content: "",
        _dirty: true,
        _pendingCreate: true,
      };
      _entityStoreMap[id] = "projects";
      return put("projects", item).then(function () {
        emit("dataChanged", { entityType: "project", op: "add", id: id });
        syncCreateToServer("projects", id);
        return id;
      });
    }

    function addCase(projectId, name) {
      var id = generateUUID();
      var now = new Date().toISOString();
      var item = {
        id: id,
        projectId: projectId,
        name: name,
        sortOrder: Date.now(),
        isActive: true,
        createdAt: now,
        updatedAt: now,
        content: "",
        _dirty: true,
        _pendingCreate: true,
      };
      _entityStoreMap[id] = "cases";
      return put("cases", item).then(function () {
        emit("dataChanged", { entityType: "case", op: "add", id: id });
        syncCreateToServer("cases", id);
        return id;
      });
    }

    function addTask(projectId, caseId, name) {
      var id = generateUUID();
      var now = new Date().toISOString();
      var item = {
        id: id,
        projectId: projectId,
        caseId: caseId || "",
        name: name,
        status: "todo",
        sortOrder: Date.now(),
        isActive: true,
        createdAt: now,
        completedAt: "",
        startedAt: "",
        dueDate: "",
        updatedAt: now,
        content: "",
        _dirty: true,
        _pendingCreate: true,
      };
      _entityStoreMap[id] = "tasks";
      return put("tasks", item).then(function () {
        emit("dataChanged", { entityType: "task", op: "add", id: id });
        syncCreateToServer("tasks", id);
        return id;
      });
    }

    function updateProject(id, fields) {
      _entityStoreMap[id] = "projects";
      return withLock(id, function () {
        return get("projects", id).then(function (item) {
          if (!item) return;
          Object.keys(fields).forEach(function (k) { item[k] = fields[k]; });
          item.updatedAt = new Date().toISOString();
          item._dirty = true;
          return put("projects", item).then(function () {
            emit("dataChanged", { entityType: "project", op: "update", id: id });
            scheduleMetadataSync("projects", id);
          });
        });
      });
    }

    function updateCase(id, fields) {
      _entityStoreMap[id] = "cases";
      return withLock(id, function () {
        return get("cases", id).then(function (item) {
          if (!item) return;
          Object.keys(fields).forEach(function (k) { item[k] = fields[k]; });
          item.updatedAt = new Date().toISOString();
          item._dirty = true;
          return put("cases", item).then(function () {
            emit("dataChanged", { entityType: "case", op: "update", id: id });
            scheduleMetadataSync("cases", id);
          });
        });
      });
    }

    function updateTask(id, fields) {
      _entityStoreMap[id] = "tasks";
      return withLock(id, function () {
        return get("tasks", id).then(function (item) {
          if (!item) return;
          var oldStatus = item.status;
          Object.keys(fields).forEach(function (k) { item[k] = fields[k]; });
          if (fields.status === "done" && oldStatus !== "done") {
            item.completedAt = new Date().toISOString();
          } else if (fields.status && fields.status !== "done" && oldStatus === "done") {
            item.completedAt = "";
          }
          item.updatedAt = new Date().toISOString();
          item._dirty = true;
          return put("tasks", item).then(function () {
            emit("dataChanged", { entityType: "task", op: "update", id: id });
            scheduleMetadataSync("tasks", id);
          });
        });
      });
    }

    function archiveProject(id) {
      return withLock(id, function () {
        return get("projects", id).then(function (item) {
          if (!item) return;
          item.isActive = false;
          item._dirty = true;
          return put("projects", item);
        });
      }).then(function () {
        return getByIndex("cases", "projectId", id).then(function (cases) {
          return Promise.all(cases.map(function (c) {
            return withLock(c.id, function () {
              return get("cases", c.id).then(function (latest) {
                if (!latest) return;
                latest.isActive = false;
                latest._dirty = true;
                return put("cases", latest);
              });
            });
          }));
        });
      }).then(function () {
        return getByIndex("tasks", "projectId", id).then(function (tasks) {
          return Promise.all(tasks.map(function (t) {
            return withLock(t.id, function () {
              return get("tasks", t.id).then(function (latest) {
                if (!latest) return;
                latest.isActive = false;
                latest._dirty = true;
                return put("tasks", latest);
              });
            });
          }));
        });
      }).then(function () {
        emit("dataChanged", { entityType: "project", op: "archive", id: id });
        syncArchiveToServer("projects", id);
      });
    }

    function archiveCase(id) {
      return withLock(id, function () {
        return get("cases", id).then(function (item) {
          if (!item) return;
          item.isActive = false;
          item._dirty = true;
          return put("cases", item);
        });
      }).then(function () {
        return getByIndex("tasks", "caseId", id).then(function (tasks) {
          return Promise.all(tasks.map(function (t) {
            return withLock(t.id, function () {
              return get("tasks", t.id).then(function (latest) {
                if (!latest) return;
                latest.isActive = false;
                latest._dirty = true;
                return put("tasks", latest);
              });
            });
          }));
        });
      }).then(function () {
        emit("dataChanged", { entityType: "case", op: "archive", id: id });
        syncArchiveToServer("cases", id);
      });
    }

    function archiveTask(id) {
      return withLock(id, function () {
        return get("tasks", id).then(function (item) {
          if (!item) return;
          item.isActive = false;
          item._dirty = true;
          return put("tasks", item).then(function () {
            emit("dataChanged", { entityType: "task", op: "archive", id: id });
            syncArchiveToServer("tasks", id);
          });
        });
      });
    }

    // =========================================================
    // Content Management (stored within entity records)
    // =========================================================
    function saveContent(id, content, storeName) {
      _entityStoreMap[id] = storeName;
      return withLock(id, function () {
        return get(storeName, id).then(function (existing) {
          if (!existing) return;
          var now = new Date().toISOString();
          existing.content = content;
          existing._contentLocalTs = now;
          return put(storeName, existing).then(function () {
            scheduleContentSync(storeName, id);
          });
        });
      });
    }

    function getContent(id, storeName) {
      return rawGet(storeName, id).then(function (record) {
        if (!record) return null;
        return record.content != null ? record.content : "";
      });
    }

    // =========================================================
    // Migration: contents store → entity stores
    // =========================================================
    function migrateContentsToEntities() {
      if (localStorage.getItem("gas_pomodoro_contents_migrated") === "1") {
        return Promise.resolve();
      }
      return getAll("contents").then(function (records) {
        if (!records || records.length === 0) {
          localStorage.setItem("gas_pomodoro_contents_migrated", "1");
          return;
        }
        var ops = records.map(function (record) {
          var targetStore = record._storeName;
          if (!targetStore) return Promise.resolve();
          return get(targetStore, record.id).then(function (entity) {
            if (!entity) return;
            if (entity.content == null || entity.content === "") {
              entity.content = record.content || "";
              entity._contentLocalTs = record.updatedAt || new Date().toISOString();
              return put(targetStore, entity);
            }
          });
        });
        return Promise.all(ops).then(function () {
          return openDB().then(function (db) {
            return new Promise(function (resolve, reject) {
              var tx = db.transaction("contents", "readwrite");
              tx.objectStore("contents").clear();
              tx.oncomplete = function () { resolve(); };
              tx.onerror = function () { reject(tx.error); };
            });
          });
        }).then(function () {
          localStorage.setItem("gas_pomodoro_contents_migrated", "1");
        });
      }).catch(function (err) {
        console.warn("[TaskStore] migration error:", err);
      });
    }

    // =========================================================
    // Sync Utilities
    // =========================================================
    function stripLocalFields(obj) {
      var result = {};
      Object.keys(obj).forEach(function (k) {
        if (k.charAt(0) !== "_") result[k] = obj[k];
      });
      return result;
    }

    function withTimeout(promise, ms) {
      return new Promise(function (resolve, reject) {
        var timer = setTimeout(function () { reject(new Error("timeout")); }, ms);
        promise.then(function (v) { clearTimeout(timer); resolve(v); },
                     function (e) { clearTimeout(timer); reject(e); });
      });
    }

    function withServerQueue(id, fn) {
      var prev = _serverQueues[id] || Promise.resolve();
      var next = prev.then(fn, fn);
      _serverQueues[id] = next;
      next.then(function () {
        if (_serverQueues[id] === next) delete _serverQueues[id];
      });
      return next;
    }

    function retryWithBackoff(fn, maxRetries) {
      maxRetries = maxRetries || 5;
      function attempt(n) {
        return fn().catch(function (err) {
          if (n >= maxRetries) {
            emit("syncError", { error: err });
            throw err;
          }
          var delay = Math.pow(2, n) * 1000;
          return new Promise(function (resolve) {
            setTimeout(resolve, delay);
          }).then(function () { return attempt(n + 1); });
        });
      }
      return attempt(0);
    }

    function storeNameToServerFns(storeName) {
      if (storeName === "projects") return { add: "addProject", update: "updateProject", archive: "archiveProject", getContent: "getProjectContent", reorder: "reorderProjects" };
      if (storeName === "cases") return { add: "addCase", update: "updateCase", archive: "archiveCase", getContent: "getCaseContent", reorder: "reorderCases" };
      return { add: "addTask", update: "updateTask", archive: "archiveTask", getContent: "getTaskContent", reorder: "reorderTasks" };
    }

    // =========================================================
    // Write Sync: IDB → Server
    // =========================================================
    function syncCreateToServer(storeName, id) {
      withServerQueue(id, function () {
        return get(storeName, id).then(function (entity) {
          if (!entity || !entity._pendingCreate) return;
          var fns = storeNameToServerFns(storeName);
          var callFn;
          if (storeName === "projects") {
            callFn = function () { return serverCall(fns.add, entity.id, entity.name, entity.color || "#4285f4"); };
          } else if (storeName === "cases") {
            callFn = function () { return serverCall(fns.add, entity.id, entity.projectId, entity.name); };
          } else {
            callFn = function () { return serverCall(fns.add, entity.id, entity.projectId, entity.caseId || "", entity.name); };
          }
          return retryWithBackoff(callFn).then(function (result) {
            return withLock(id, function () {
              return get(storeName, id).then(function (latest) {
                if (!latest) return;
                latest._pendingCreate = false;
                latest._dirty = false;
                latest._lastServerUpdatedAt = result.updatedAt;
                return put(storeName, latest);
              });
            });
          });
        });
      }).catch(function (err) {
        console.error("[TaskStore] syncCreateToServer failed:", storeName, id, err);
      });
    }

    function scheduleMetadataSync(storeName, id) {
      if (_metaDebounces[id]) clearTimeout(_metaDebounces[id]);
      _metaDebounces[id] = setTimeout(function () {
        delete _metaDebounces[id];
        syncMetadataToServer(storeName, id);
      }, 1000);
    }

    function syncMetadataToServer(storeName, id) {
      withServerQueue(id, function () {
        return get(storeName, id).then(function (entity) {
          if (!entity) return;
          if (entity._pendingCreate) return;
          var clean = stripLocalFields(entity);
          delete clean.id;
          delete clean.createdAt;
          delete clean.content;
          var fns = storeNameToServerFns(storeName);
          return retryWithBackoff(function () {
            return serverCall(fns.update, id, clean);
          }).then(function (result) {
            if (!result || !result.updatedAt) return;
            return withLock(id, function () {
              return get(storeName, id).then(function (latest) {
                if (!latest) return;
                latest._dirty = false;
                latest._lastServerUpdatedAt = result.updatedAt;
                return put(storeName, latest);
              });
            });
          });
        });
      }).catch(function (err) {
        console.error("[TaskStore] syncMetadataToServer failed:", storeName, id, err);
      });
    }

    function syncArchiveToServer(storeName, id) {
      withServerQueue(id, function () {
        return get(storeName, id).then(function (entity) {
          if (!entity) return;
          if (entity._pendingCreate) return;
          var fns = storeNameToServerFns(storeName);
          return retryWithBackoff(function () {
            return serverCall(fns.archive, id);
          }).then(function () {
            return withLock(id, function () {
              return get(storeName, id).then(function (latest) {
                if (!latest) return;
                latest._dirty = false;
                return put(storeName, latest);
              });
            });
          });
        });
      }).catch(function (err) {
        console.error("[TaskStore] syncArchiveToServer failed:", storeName, id, err);
      });
    }

    function scheduleContentSync(storeName, id) {
      if (_contentSyncDebounces[id]) clearTimeout(_contentSyncDebounces[id]);
      _contentSyncDebounces[id] = setTimeout(function () {
        delete _contentSyncDebounces[id];
        syncContentToServer(storeName, id);
      }, 30000);
    }

    function flushContentSync(storeName, id) {
      if (_contentSyncDebounces[id]) {
        clearTimeout(_contentSyncDebounces[id]);
        delete _contentSyncDebounces[id];
      }
      syncContentToServer(storeName, id);
    }

    function syncContentToServer(storeName, id) {
      withServerQueue(id, function () {
        return get(storeName, id).then(function (entity) {
          if (!entity) return;
          if (entity._pendingCreate) return;
          if (entity._contentLocalTs && entity._contentSyncedTs && entity._contentLocalTs <= entity._contentSyncedTs) return;
          var fns = storeNameToServerFns(storeName);
          var content = entity.content || "";
          return retryWithBackoff(function () {
            return serverCall(fns.update, id, { content: content });
          }).then(function (result) {
            if (!result || !result.updatedAt) return;
            return withLock(id, function () {
              return get(storeName, id).then(function (latest) {
                if (!latest) return;
                latest._contentSyncedTs = entity._contentLocalTs;
                latest._lastServerUpdatedAt = result.updatedAt;
                return put(storeName, latest);
              });
            });
          });
        });
      }).catch(function (err) {
        console.error("[TaskStore] syncContentToServer failed:", storeName, id, err);
      });
    }

    function scheduleReorderSync(storeName, args) {
      var state = _reorderState[storeName];
      state.pending = args;
      if (_reorderDebounces[storeName]) clearTimeout(_reorderDebounces[storeName]);
      _reorderDebounces[storeName] = setTimeout(function () {
        delete _reorderDebounces[storeName];
        flushReorderSync(storeName);
      }, 5000);
    }

    function flushReorderSync(storeName) {
      var state = _reorderState[storeName];
      if (state.saving) return;
      if (!state.pending) return;
      var args = state.pending;
      state.pending = null;
      state.saving = true;
      var fns = storeNameToServerFns(storeName);
      serverCall.apply(null, [fns.reorder].concat(args))
        .catch(function (err) {
          console.error("[TaskStore] reorder sync failed:", storeName, err);
        })
        .then(function () {
          state.saving = false;
          if (state.pending) flushReorderSync(storeName);
        });
    }

    function flushAllSyncs() {
      // Flush metadata debounces
      Object.keys(_metaDebounces).forEach(function (id) {
        clearTimeout(_metaDebounces[id]);
        delete _metaDebounces[id];
        var storeName = _entityStoreMap[id];
        if (storeName) syncMetadataToServer(storeName, id);
      });
      // Flush content sync debounces
      Object.keys(_contentSyncDebounces).forEach(function (id) {
        clearTimeout(_contentSyncDebounces[id]);
        delete _contentSyncDebounces[id];
        var storeName = _entityStoreMap[id];
        if (storeName) syncContentToServer(storeName, id);
      });
      // Flush reorder debounces
      ["projects", "cases", "tasks"].forEach(function (sn) {
        if (_reorderDebounces[sn]) {
          clearTimeout(_reorderDebounces[sn]);
          delete _reorderDebounces[sn];
        }
        flushReorderSync(sn);
      });
    }

    // =========================================================
    // Read Sync: Server → IDB
    // =========================================================
    function mergeServerData(serverData) {
      var storeNames = ["projects", "cases", "tasks"];
      var serverSets = {
        projects: serverData.projects || [],
        cases: serverData.cases || [],
        tasks: serverData.tasks || []
      };
      return Promise.all(storeNames.map(function (storeName) {
        return mergeEntityStore(storeName, serverSets[storeName]);
      })).then(function () {
        emit("dataChanged", { entityType: "all", op: "serverSync" });
      });
    }

    function mergeEntityStore(storeName, serverEntities) {
      return getAll(storeName).then(function (localEntities) {
        var localMap = {};
        localEntities.forEach(function (e) { localMap[e.id] = e; });
        var serverMap = {};
        serverEntities.forEach(function (e) { serverMap[e.id] = e; });

        var ops = [];

        // 1. Server only → insert into IDB
        serverEntities.forEach(function (se) {
          if (!localMap[se.id]) {
            se._lastServerUpdatedAt = se.updatedAt;
            se.content = se.content || "";
            ops.push(put(storeName, se));
          }
        });

        // 2. Local only
        localEntities.forEach(function (le) {
          if (!serverMap[le.id]) {
            if (!le._lastServerUpdatedAt) {
              // Never synced — set _pendingCreate flag and push to server
              ops.push(withLock(le.id, function () {
                return get(storeName, le.id).then(function (latest) {
                  if (!latest) return;
                  latest._pendingCreate = true;
                  latest._dirty = true;
                  if (latest.content == null) latest.content = "";
                  return put(storeName, latest);
                });
              }).then(function () {
                syncCreateToServer(storeName, le.id);
              }));
            } else {
              // Was synced before but gone from server — remove locally
              ops.push(remove(storeName, le.id));
            }
          }
        });

        // 3. Both exist
        serverEntities.forEach(function (se) {
          var le = localMap[se.id];
          if (!le) return;
          _entityStoreMap[se.id] = storeName;
          if (!le._dirty) {
            // No local changes — take server metadata, preserve local content and _ fields
            var merged = {};
            Object.keys(se).forEach(function (k) { merged[k] = se[k]; });
            // Preserve local-only fields
            Object.keys(le).forEach(function (k) {
              if (k.charAt(0) === "_" || k === "content") {
                merged[k] = le[k];
              }
            });
            merged._lastServerUpdatedAt = se.updatedAt;
            merged._dirty = false;
            ops.push(put(storeName, merged));
          } else {
            // Local is dirty — just update server timestamp, keep local data, re-push
            ops.push(withLock(se.id, function () {
              return get(storeName, se.id).then(function (latest) {
                if (!latest) return;
                latest._lastServerUpdatedAt = se.updatedAt;
                return put(storeName, latest);
              });
            }));
            scheduleMetadataSync(storeName, se.id);
          }
        });

        return Promise.all(ops);
      });
    }

    function requeueDirtyRecords() {
      var storeNames = ["projects", "cases", "tasks"];
      storeNames.forEach(function (storeName) {
        getAll(storeName).then(function (entities) {
          entities.forEach(function (entity) {
            _entityStoreMap[entity.id] = storeName;
            if (entity._pendingCreate) {
              syncCreateToServer(storeName, entity.id);
            } else if (entity._dirty) {
              scheduleMetadataSync(storeName, entity.id);
            }
            if (entity._contentLocalTs && (!entity._contentSyncedTs || entity._contentLocalTs > entity._contentSyncedTs)) {
              scheduleContentSync(storeName, entity.id);
            }
          });
        }).catch(function (err) {
          console.warn("[TaskStore] requeueDirtyRecords error:", storeName, err);
        });
      });
    }

    // =========================================================
    // Content Conflict Resolution
    // =========================================================
    function applyServerContent(id, storeName, content, serverTs) {
      return withLock(id, function () {
        return get(storeName, id).then(function (entity) {
          if (!entity) return;
          entity.content = content;
          entity._contentSyncedTs = serverTs;
          entity._contentLocalTs = serverTs;
          return put(storeName, entity);
        });
      });
    }

    function resolveContentConflict(id, storeName, serverResult) {
      return get(storeName, id).then(function (entity) {
        if (!entity) return null;
        var localContent = entity.content || "";
        var serverContent = (serverResult && serverResult.content) || "";
        var serverTs = (serverResult && serverResult.updatedAt) || "";
        var syncedTs = entity._contentSyncedTs || "";
        var localTs = entity._contentLocalTs || "";

        if (!syncedTs) {
          // First sync — no synced timestamp
          if (localTs && localContent) {
            // Local has edits — push to server
            scheduleContentSync(storeName, id);
            return withLock(id, function () {
              return get(storeName, id).then(function (latest) {
                if (!latest) return null;
                latest._contentSyncedTs = localTs;
                return put(storeName, latest).then(function () {
                  return { useServer: false };
                });
              });
            });
          } else {
            // No local edits — use server
            return applyServerContent(id, storeName, serverContent, serverTs).then(function () {
              return { useServer: true, content: serverContent };
            });
          }
        }

        var hasLocalEdits = !!(localTs && syncedTs && localTs > syncedTs);
        var serverIsNewer = !!(serverTs && serverTs !== syncedTs);

        if (hasLocalEdits && serverIsNewer) {
          // Conflict
          var useServer = confirm("サーバーに新しいバージョンがあります。サーバーの内容を使用しますか？\n（キャンセルでローカルの変更を維持）");
          if (useServer) {
            return applyServerContent(id, storeName, serverContent, serverTs).then(function () {
              return { useServer: true, content: serverContent };
            });
          } else {
            scheduleContentSync(storeName, id);
            return Promise.resolve({ useServer: false });
          }
        } else if (hasLocalEdits) {
          // Local only changed — push
          scheduleContentSync(storeName, id);
          return Promise.resolve({ useServer: false });
        } else if (serverIsNewer) {
          // Server only changed — use server
          return applyServerContent(id, storeName, serverContent, serverTs).then(function () {
            return { useServer: true, content: serverContent };
          });
        } else {
          // No changes
          return Promise.resolve({ useServer: false });
        }
      });
    }

    function resolveWithServer(id, storeName) {
      var fns = storeNameToServerFns(storeName);
      return withTimeout(serverCall(fns.getContent, id), 5000)
        .then(function (serverResult) {
          return resolveContentConflict(id, storeName, serverResult);
        })
        .catch(function () {
          return null;
        });
    }

    // =========================================================
    // Query API
    // =========================================================
    function getProjects() {
      return getAll("projects").then(function (items) {
        return items
          .filter(function (p) { return p.isActive !== false; })
          .sort(function (a, b) { return (a.sortOrder || 0) - (b.sortOrder || 0); });
      });
    }

    function getCases(projectId) {
      return getByIndex("cases", "projectId", projectId).then(function (items) {
        return items
          .filter(function (c) { return c.isActive !== false; })
          .sort(function (a, b) { return (a.sortOrder || 0) - (b.sortOrder || 0); });
      });
    }

    var STATUS_ORDER = { docs: 0, doing: 1, review: 2, todo: 3, pending: 4, done: 5 };

    function getTasks(projectId, caseId) {
      var indexName = caseId ? "caseId" : "projectId";
      var indexVal = caseId || projectId;
      return getByIndex("tasks", indexName, indexVal).then(function (items) {
        return items
          .filter(function (t) {
            if (t.isActive === false) return false;
            if (caseId) return true;
            return !t.caseId;
          })
          .sort(function (a, b) {
            var sa = STATUS_ORDER[a.status] !== undefined ? STATUS_ORDER[a.status] : 99;
            var sb = STATUS_ORDER[b.status] !== undefined ? STATUS_ORDER[b.status] : 99;
            if (sa !== sb) return sa - sb;
            return (a.createdAt || "").localeCompare(b.createdAt || "");
          });
      });
    }

    function getAllProjects() { return getProjects(); }
    function getAllCases() {
      return getAll("cases").then(function (items) {
        return items.filter(function (c) { return c.isActive !== false; });
      });
    }
    function getAllTasks() {
      return getAll("tasks").then(function (items) {
        return items.filter(function (t) { return t.isActive !== false; });
      });
    }

    // =========================================================
    // Reorder
    // =========================================================
    function reorderProjects(orderedIds) {
      var entries = orderedIds.map(function (id, i) {
        return { id: id, sortOrder: i + 1 };
      });
      return updateSortOrders("projects", entries).then(function () {
        emit("dataChanged", { entityType: "project", op: "reorder" });
        scheduleReorderSync("projects", [orderedIds]);
      });
    }

    function reorderCases(projectId, orderedIds) {
      var entries = orderedIds.map(function (id, i) {
        return { id: id, sortOrder: i + 1 };
      });
      return updateSortOrders("cases", entries).then(function () {
        emit("dataChanged", { entityType: "case", op: "reorder" });
        scheduleReorderSync("cases", [projectId, orderedIds]);
      });
    }

    function reorderTasks(parentId, orderedIds) {
      var entries = orderedIds.map(function (id, i) {
        return { id: id, sortOrder: i + 1 };
      });
      return updateSortOrders("tasks", entries).then(function () {
        emit("dataChanged", { entityType: "task", op: "reorder" });
        scheduleReorderSync("tasks", [parentId, orderedIds]);
      });
    }

    // =========================================================
    // Init
    // =========================================================
    function init() {
      return openDB().then(function () {
        return migrateContentsToEntities();
      }).then(function () {
        // Background: requeue dirty records and pull server data
        requeueDirtyRecords();
        serverCall("getAllTaskData").then(function (data) {
          return mergeServerData(data);
        }).catch(function (err) {
          console.warn("[TaskStore] server sync failed:", err);
        });

        // Flush on page close / tab hide
        window.addEventListener("beforeunload", flushAllSyncs);
        document.addEventListener("visibilitychange", function () {
          if (document.visibilityState === "hidden") flushAllSyncs();
        });
      });
    }

    // =========================================================
    // Public API
    // =========================================================
    return {
      init: init,
      on: on,
      getProjects: getProjects,
      getCases: getCases,
      getTasks: getTasks,
      getAllProjects: getAllProjects,
      getAllCases: getAllCases,
      getAllTasks: getAllTasks,
      addProject: addProject,
      addCase: addCase,
      addTask: addTask,
      updateProject: updateProject,
      updateCase: updateCase,
      updateTask: updateTask,
      archiveProject: archiveProject,
      archiveCase: archiveCase,
      archiveTask: archiveTask,
      reorderProjects: reorderProjects,
      reorderCases: reorderCases,
      reorderTasks: reorderTasks,
      saveContent: saveContent,
      getContent: getContent,
      withLock: withLock,
      rawGet: rawGet,
      get: get,
      put: put,
      updateEntity: updateEntity,
      updateSortOrders: updateSortOrders,
      flushContentSync: flushContentSync,
      flushAllSyncs: flushAllSyncs,
      resolveWithServer: resolveWithServer,
    };
  })();
</script>
